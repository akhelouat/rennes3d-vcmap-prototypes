/**
 * If invalid arguments are passed to a function, this error can be thrown, warning the
 * developer of a miss-configuration and to assist debugging
 * @typedef {Error} vcs.vcm.util.InvalidArgument
 * @api stable
 */

/**
 * @type {Array<Array<Function|undefined|string>>}
 */
const patterns = [
  [String, 'string'],
  [Number, 'number'],
  [Boolean, 'boolean'],
  [Function, 'function'],
  [undefined, 'undefined'],
  [Symbol, 'symbol'],
];

/**
 * @param {*} value
 * @returns {boolean}
 */
function isPlainObject(value) {
  const classType = {};

  if (!value || classType.toString(value) !== '[object Object]') {
    return false;
  }

  const proto = Object.getPrototypeOf(value);
  if (!proto) {
    return true;
  }

  const hasOwn = classType.hasOwnProperty;

  const Ctor = hasOwn.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor === 'function' && hasOwn.toString.call(Ctor) === hasOwn.toString.call(Object);
}

/**
 * @param {*} value
 * @param {boolean=} onlyType
 * @returns {string}
 */
function getErrorValue(value, onlyType) {
  if (value === null) {
    return 'null';
  }

  if (typeof value === 'undefined') {
    return 'undefined';
  }

  if (onlyType) {
    return typeof value;
  }

  let string;
  if (Array.isArray(value)) {
    const values = value.map((entry) => {
      return getErrorValue(entry, onlyType);
    });
    string = `[${values.join(',')}]`;
  } else {
    try {
      string = JSON.stringify(value);
    } catch (err) {
      string = typeof value;
    }
  }
  string = string || typeof value;

  if (string.length > 20) {
    return `${string.substr(0, 20)}...`;
  }
  return string;
}

/**
 * @param {*} valueToTest
 * @param {string|number|boolean} pattern
 * @returns {null|string|boolean}
 */
function checkValue(valueToTest, pattern) {
  if (
    typeof pattern === 'string' ||
    typeof pattern === 'number' ||
    typeof pattern === 'boolean' ||
    typeof pattern === 'symbol'
  ) {
    if (valueToTest === pattern) {
      return false;
    }
    return `Expected ${getErrorValue(valueToTest)} to equal ${pattern.toString()}`;
  }
  return null;
}

/**
 * @param {*} value
 * @param {Array<*>} pattern
 * @param {boolean=} strict
 * @returns {null|string|boolean}
 */
function array(value, pattern, strict) {
  if (Array.isArray(pattern)) {
    if (pattern.length !== 1) {
      throw new Error('Array patterns may only have on type');
    }

    if (Array.isArray(value)) {
      let message = false;
      const error = value.findIndex((member) => {
        try {
          // eslint-disable-next-line no-use-before-define
          check(member, pattern[0], strict);
        } catch (err) {
          message = err.message.replace(/Match failed:\s/, '');
        }
        return message;
      });
      if (error > -1) {
        return `${message} in ${getErrorValue(value)}`;
      }
      return false;
    }

    return `Expected ${getErrorValue(value)} to be an Array`;
  }
  return null;
}

/**
 * @param {*} value
 * @param {Object<string, *>} pattern
 * @param {string=} path
 * @returns {string|boolean}
 */
function object(value, pattern, path) {
  const keyPath = path ? `${path}.` : '';
  const isPlain = isPlainObject(value);
  if (!isPlain) {
    return `Expected ${getErrorValue(value)} to be a plain Object`;
  }

  let message = false;
  const wrongKey = Object.keys(pattern).find((key) => {
    const nestedValue = value[key];
    if (isPlainObject(pattern[key])) {
      message = object(nestedValue, pattern[key], keyPath + key);
    } else {
      try {
        // eslint-disable-next-line no-use-before-define
        check(nestedValue, pattern[key]);
      } catch (err) {
        message = err.message.replace(/Match failed:\s/, '');
      }
    }
    return message;
  });

  if (wrongKey) {
    return `${message} in object.${keyPath}${wrongKey}`;
  }
  return false;
}

/**
 * @param {*} value
 * @param {Function} pattern
 * @returns {null|string|boolean}
 */
function atomic(value, pattern) {
  if (pattern === Number) {
    if (Number.isFinite(value)) {
      return false;
    }
    return `expected ${getErrorValue(value)} to be a number, excluding NaN`;
  }
  // eslint-disable-next-line no-plusplus
  for (let i = patterns.length; i--;) {
    if (pattern === patterns[i][0]) {
      // eslint-disable-next-line valid-typeof
      if (typeof value === patterns[i][1]) {
        return false;
      }
      return `expected ${getErrorValue(value)} to be a ${patterns[i][1]}`;
    }
  }
  return null;
}

/**
 * @param {*} value
 * @returns {string}
 */
function getConstructorString(value) {
  if (value === null) {
    return 'null';
  }

  const hasPattern = patterns.find(pattern => pattern[0] === value);

  if (hasPattern) {
    return hasPattern[1];
  }

  let toString = value.toString();
  if (value.className) {
    return value.className;
  }

  const constructor = toString.match(/function (.*)\(/);
  if (constructor && constructor.length > 1) {
    return constructor[1];
  }

  if (isPlainObject(value)) {
    const obj = {};
    Object.keys(value).forEach((key) => {
      obj[key] = getConstructorString(value[key]);
    });

    try {
      toString = `Object of ${JSON.stringify(obj)}`;
    } catch (ex) {
      toString = 'Object';
    }
  }

  return toString;
}

/**
 * @param {Object<string, *>} value
 * @param {Object<string, *>} pattern
 * @param {string=} path
 * @returns {string|boolean}
 */
function requireKeys(value, pattern, path) {
  const keyPath = path ? `${path}.` : '';
  let message = false;
  const missingKey = Object.keys(value).find((valueKey) => {
    if (isPlainObject(pattern[valueKey])) {
      const nestedValue = value[valueKey];
      message = requireKeys(nestedValue, pattern[valueKey], keyPath + valueKey);
    } else if (!pattern[valueKey]) {
      message = `Found additional key ${keyPath}${valueKey}`;
    }
    message = message ? message.replace(/\sin.*/, '') : false;
    return message;
  });

  if (missingKey) {
    return `${message} in ${getErrorValue(value)}`;
  }
  return false;
}

/**
 * Checks the value to be of type pattern
 * @param {*} value
 * @param {*} pattern
 * @param {boolean=} strict
 * @returns {string|false} - returns an error message or false
 * @export
 */
function internalTest(value, pattern, strict) {
  const test = function test(testValue, testPattern) {
    if (testPattern == null) {
      if (testValue === testPattern) {
        return false;
      }
      return `Expected ${getErrorValue(testValue)} to be ${testPattern}`;
    }

    const isAtomic = atomic(testValue, testPattern);
    if (isAtomic !== null) {
      return isAtomic;
    }

    const isValue = checkValue(testValue, testPattern);
    if (isValue !== null) {
      return isValue;
    }

    if (Array.isArray(testPattern)) {
      return array(testValue, testPattern, strict);
    }

    if (testPattern instanceof Function) { // assumes constructor
      if (testValue instanceof testPattern) {
        return false;
      }
      return `Expected ${getErrorValue(testValue, true)} to be of Type ${getConstructorString(testPattern)}`;
    }

    if (testPattern === Object) {
      return object(testValue, {});
    }

    if (typeof testPattern !== 'object') {
      throw new Error(`Cannot handler pattern ${testPattern}`);
    }

    const objError = object(testValue, testPattern);
    if (objError) {
      return objError;
    }

    if (strict) {
      return requireKeys(testValue, testPattern);
    }
    return false;
  };

  let error;
  if (Array.isArray(pattern) && pattern.length > 1) {
    const failed = pattern.every((oneOf) => {
      const testRes = test(value, oneOf);
      return testRes;
    });

    if (failed) {
      error = `Expected ${getErrorValue(value)} to be a ${pattern.map(oneOf => getConstructorString(oneOf)).join(' or ')}`;
    }
  } else {
    error = test(value, pattern);
  }
  return error;
}

/**
 * Checks the value to be of type pattern
 * @param {*} value
 * @param {*} pattern
 * @param {boolean=} strict
 * @returns {boolean}
 * @export
 */
export function is(value, pattern, strict) {
  return !internalTest(value, pattern, strict);
}

/**
 * Checks the value to be of type pattern or undefined or null
 * @param {*} value
 * @param {*} pattern
 * @param {boolean=} strict
 * @returns {boolean}
 * @export
 */
export function isMaybe(value, pattern, strict) {
  const patternArray = [null, undefined];
  if (Array.isArray(pattern) && pattern.length > 1) {
    pattern.forEach((oneOf) => {
      patternArray.push(oneOf);
    });
  } else {
    patternArray.push(pattern);
  }

  return is(value, patternArray.reverse(), strict);
}

/**
 * Checks the value to be of type pattern
 * @param {*} value
 * @param {*} pattern
 * @param {boolean=} strict
 * @returns {boolean} returns false if all checks have passed
 * @export
 */
export function check(value, pattern, strict) {
  const error = internalTest(value, pattern, strict);
  if (error) {
    throw new Error(`Match failed: ${error}`);
  }
  return false;
}

/**
 * Convenience function
 * Checks the value, if defined and not null, to be of type pattern
 * @param {*} value
 * @param {*} pattern
 * @param {boolean=} strict
 * @returns {boolean}
 * @export
 */
export function checkMaybe(value, pattern, strict) {
  const patternArray = [null, undefined];
  if (Array.isArray(pattern) && pattern.length > 1) {
    pattern.forEach((oneOf) => {
      patternArray.push(oneOf);
    });
  } else {
    patternArray.push(pattern);
  }

  return check(value, patternArray.reverse(), strict);
}
