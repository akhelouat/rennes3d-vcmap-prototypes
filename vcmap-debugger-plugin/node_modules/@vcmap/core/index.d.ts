import olFeature from 'ol/Feature';
import Geometry from 'ol/geom/Geometry';

export interface AppBackedCategoryOptions extends CategoryOptions {
    collectionName: string;
}

export class AppBackedCategory extends Category<VcsObject> {
    constructor(options: AppBackedCategoryOptions);
    protected _deserializeItem(config: VcsObjectOptions): Promise<VcsObject>;
    serializeForContext(contextId: string): null;
}

/**
 */
export interface CategoryOptions extends VcsObjectOptions {
    title?: string | {
        [key: string]: string;
    };
    /**
     * the class registry name on the current app to provide classes for this category. if provided, parseItems will deserialize using this class registry. See: {@link getObjectFromClassRegistry}.
    */
    classRegistryName?: string;
    featureProperty?: string | undefined;
    layerOptions?: VectorOptions;
    /**
     * items are not evaluated by the constructor but passed to parseItem during deserialization.
    */
    items?: object[];
    keyProperty?: string;
}

/**
 * A category contains user based items and is a special container. The container should not be created directly, but via
 * the requestCategory API on the categories collection. Do not use toJSON to retrieve the state of a category, since
 * categories outlive contexts and may be changed with mergeOptions to no longer reflect your initial state. Requestors
 * should keep track of the requested options themselves.
 */
export class Category<T extends Object|VcsObject> extends VcsObject {
    constructor(options: CategoryOptions);
    static getDefaultConfig(): CategoryOptions;
    title: string | {
        [key: string]: string;
    };
    protected _app: VcsApp;
    protected _layer: VectorLayer;
    readonly classRegistryName: string;
    /**
     * The collection of this category.
     */
    readonly collection: OverrideCollection<T>;
    /**
     * Returns the layer of this collection. Caution, do not use the layer API to add or remove items.
     * When adding items to the collection, the features are added to the layer async (timeout of 0), since there is weird behavior
     * when removing and adding a feature with the same id in the same sync call.
     */
    layer: VectorLayer | null;
    protected _itemAdded(item: T): void;
    protected _itemRemoved(item: T): void;
    protected _itemReplaced(item: T): void;
    protected _itemMoved(item: T): void;
    /**
     * Throws if typed, featureProperty and keyProperty do not match. Merges other options.
     * Only merges: style, highlightStyle, zIndex & vectorProperties from layerOptions.
     */
    mergeOptions(options: CategoryOptions): void;
    /**
     * When setting the category, it MUST use the same unqiueKey as the previous collection (default is "name").
     * All items in the current collection _will be destroyed_ and the current collection will be destroyed. The category will take
     * complete ownership of the collection and destroy it once the category is destroyed. The collection will
     * be turned into an {@see OverrideCollection}.
     */
    setCollection(collection: Collection<T>): void;
    setApp(app: VcsApp): void;
    /**
     * @returns // XXX should this still be async?
     */
    protected _deserializeItem(config: any): Promise<T>;
    protected _serializeItem(item: T): object[];
    serializeForContext(contextId: string): CategoryOptions | null;
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
}

export class CategoryCollection extends IndexedCollection<Category<Object|VcsObject>> {
    constructor(app: VcsApp);
    /**
     * Do not call add directly. Use request category for adding categories.
     */
    add(category: Category<object | VcsObject>): number | null;
    /**
     * Categories should be static. Removing them can lead to undefined behavior.
     */
    remove(category: Category<object | VcsObject>): void;
    /**
     * Parses the category items. Items will only be parsed, if a category with said name exists. Otherwise,
     * they will be cached, until such a category is requested.
     */
    parseCategoryItems(name: string, items: object[], contextId: string): Promise<void>;
    /**
     * Add categories with this API.
     */
    requestCategory(options: CategoryOptions): Promise<Category<object | VcsObject>>;
}

export interface VcsCameraPrimitiveOptions {
    camera: import("@vcmap/cesium").Camera;
    color?: import("@vcmap/cesium").Color | undefined;
    show?: boolean | undefined;
    allowPicking?: boolean | undefined;
    id?: any | undefined;
}

export class VcsCameraPrimitive {
    constructor(options: VcsCameraPrimitiveOptions);
    show: boolean;
}

export class ClassRegistry<T extends Object|VcsObject> {
    getClassNames(): string[];
    /**
     * Register a class by its class name.
     */
    registerClass(className: string, ctor: (...params: any[]) => any): void;
    /**
     * Gets the constructor for a registered class or undefined, if no such class was registerd
     */
    getClass(className: string): ((...params: any[]) => any) | undefined;
    hasClass(className: string): boolean;
    create(className: string, ...args: any[]): T;
    createFromTypeOptions(options: any, ...args: any[]): T;
}

export const layerClassRegistry: ClassRegistry<Layer>;

export const tileProviderClassRegistry: ClassRegistry<TileProvider>;

export const featureProviderClassRegistry: ClassRegistry<AbstractFeatureProvider>;

export const mapClassRegistry: ClassRegistry<VcsMap>;

export const styleClassRegistry: ClassRegistry<StyleItem>;

export const categoryClassRegistry: ClassRegistry<Category<any>>;

/**
 * Returns an object based on a class registry or override class registry and a typed options object. as opposed to ClassRegistry.createFromTypedOptions, this function never throws.
 */
export function getObjectFromClassRegistry<T extends Object|VcsObject>(classRegistry: OverrideClassRegistry<T> | ClassRegistry<T>, options: any, ...args: any[]): T | null;

export interface VcsAppConfig {
    id?: string | undefined;
    layers?: LayerOptions[];
    maps?: VcsMapOptions[];
    styles?: StyleItemOptions[];
    viewpoints?: ViewPointOptions[];
    startingViewPointName?: string;
    startingMapName?: string;
    projection?: ProjectionOptions;
    categories?: { name: string; items: object[]; }[];
    obliqueCollections?: ObliqueCollectionOptions[];
}

export class Context {
    constructor(config: VcsAppConfig);
    readonly id: string;
    readonly checkSum: string;
    readonly config: VcsAppConfig;
}

/**
 */
export interface AbstractFeatureProviderOptions extends VcsObjectOptions {
    /**
     * the style to apply to features created by this feature provider
    */
    style?: StyleItemOptions | StyleItem | undefined;
    /**
     * generic properties to add to features created by this feature provider
    */
    genericFeatureProperties?: any | undefined;
    /**
     * the vector properties of the features. Allow picking is false by default.
    */
    vectorProperties?: VectorProperties | VectorPropertiesOptions | undefined;
    /**
     * show the resulting geometry in the map
    */
    showGeometry?: boolean;
    /**
     * can be used to constrict the featureProvider to specific mapTypes empty array means no restriction
    */
    mapTypes?: string[];
}

/**
 * An abstract class providing features for {@link Layer}s which cannot provide features directly, but can provide features for
 * a given location, e.g. WmsLayer with a getFeatureInfo configuration. In this case, a feature provider can be created for this layer.
 */
export class AbstractFeatureProvider {
    constructor(layerName: string, options: AbstractFeatureProviderOptions);
    static getDefaultOptions(): AbstractFeatureProviderOptions;
    /**
     * The layer name of the associated layer
     */
    layerName: string;
    /**
     * The style set on features created by this provider
     */
    style: StyleItem | undefined;
    /**
     * Whether to show the geometry on selection.
     */
    showGeometry: boolean;
    /**
     * The vector properties assigned to features created by this provider
     */
    vectorProperties: VectorProperties;
    /**
     * An object of potential generic feature properties to add to all feature created by this provider
     */
    genericFeatureProperties: {
        [key: string]: any;
    } | undefined;
    /**
     * Map ClassNames Can be used to only apply this featureProvider to the specified maps
     */
    mapTypes: string[];
    /**
     * checks if the featureProvider is supported for provided Map
     */
    isSupported(map: VcsMap): boolean;
    /**
     * Ensures the feature has an ID, applies all vectorProperties and adds the generic properties, style and the vcsLayerName
     * and isProvidedFeature symbols to the feature
     */
    getProviderFeature(feature: import("ol").Feature<import("ol/geom/Geometry").default>): import("ol").Feature<import("ol/geom/Geometry").default>;
    /**
     * This method must be overwritten by any implementations. Before returning the array of features, be sure to use the getProviderFeature
     * on each feature to ensure all properties and symbols required by the VCM architecture
     * to handle your feature is called: (e.g. <code>return features.map(f => this.getProviderFeature(f)</code>);
     * @param coordinate - in mercator
     * @param resolution - meters per pixel for the given location
     */
    getFeaturesByCoordinate(coordinate: import("ol/coordinate").Coordinate, resolution: number): Promise<import("ol").Feature<import("ol/geom/Geometry").default>[]>;
    /**
     * Returns the object required to configure this feature provider.
     */
    toJSON(): AbstractFeatureProviderOptions;
    /**
     * Destroys this feature provider and detaches its resources
     */
    destroy(): void;
}

export function getGenericFeatureFromProvidedFeature(feature: VectorClickedObject, layer: Layer): GenericFeature;

/**
 * Added to ol.Feature, if they are not part of a layer, but provided by an {@link AbstractFeatureProvider}.
 */
export const isProvidedFeature: symbol;

/**
 * A boolean value, indicating whether {@link SelectBehavior} should add the feature to the selected item layer
 */
export const showProvidedFeature: symbol;

export interface TileProviderFeatureProviderOptions extends AbstractFeatureProviderOptions {
    tileProvider: TileProvider;
}

export class TileProviderFeatureProvider extends AbstractFeatureProvider {
    constructor(layerName: string, options: TileProviderFeatureProviderOptions);
    /**
     * Map ClassNames Can be used to only apply this featureProvider to the specified maps
     */
    mapTypes: string[];
    /**
     * TileProvider
     */
    tileProvider: TileProvider;
    /**
     * The layer name of the associated layer
     */
    layerName: string;
    /**
     * The style set on features created by this provider
     */
    style: StyleItem | undefined;
    /**
     * Whether to show the geometry on selection.
     */
    showGeometry: boolean;
    /**
     * The vector properties assigned to features created by this provider
     */
    vectorProperties: VectorProperties;
    /**
     * An object of potential generic feature properties to add to all feature created by this provider
     */
    genericFeatureProperties: {
        [key: string]: any;
    } | undefined;
}

/**
 */
export interface WMSFeatureProviderOptions extends AbstractFeatureProviderOptions {
    /**
     * the response type for the feature info
    */
    responseType?: string | undefined;
    /**
     * format options for the GeojsonLayer, WfsLayer or GML format. To overwrite the gmlFormat option in WfsLayer format, use 'GML', 'GML2' or 'GML3' as string
    */
    formatOptions?: any | undefined;
    /**
     * the projection of the data, if not encoded in the response
    */
    projection?: ProjectionOptions | undefined;
    url: string;
    /**
     * either "geographic" or "mercator"
    */
    tilingSchema?: string;
    maxLevel?: number;
    minLevel?: number;
    tileSize?: import("ol/size").Size;
    extent?: Extent | ExtentOptions | undefined;
    parameters: {
        [key: string]: string;
    };
    version?: string;
}

export function getFormat(responseType: string, options: any): null | import("ol/format/Feature").default;

export class WMSFeatureProvider extends AbstractFeatureProvider {
    constructor(layerName: string, options: WMSFeatureProviderOptions);
    static getDefaultOptions(): WMSFeatureProviderOptions;
    extent: Extent | null;

    /**
     * The WmsLayer Source used to generate getFeatureInfo urls
     */
    wmsSource: import("ol/source/TileWMS").default;
    /**
     * The response type of the get feature info response, e.g. text/xml
     */
    featureInfoResponseType: string;
    /**
     * The feature response format determined by the response type. Use formatOptions to configure the underlying ol.format.Feature
     */
    featureFormat: import("ol/format/Feature").default;
    /**
     * The feature response projection, if not present in the response format.
     */
    projection: Projection;
    featureResponseCallback(data: import("ol/format/GeoJSON").GeoJSONObject, coordinate: import("ol/coordinate").Coordinate): import("ol").Feature<import("ol/geom/Geometry").default>[];
    /**
     * The layer name of the associated layer
     */
    layerName: string;
    /**
     * The style set on features created by this provider
     */
    style: StyleItem | undefined;
    /**
     * Whether to show the geometry on selection.
     */
    showGeometry: boolean;
    /**
     * The vector properties assigned to features created by this provider
     */
    vectorProperties: VectorProperties;
    /**
     * An object of potential generic feature properties to add to all feature created by this provider
     */
    genericFeatureProperties: {
        [key: string]: any;
    } | undefined;
    /**
     * Map ClassNames Can be used to only apply this featureProvider to the specified maps
     */
    mapTypes: string[];
}

/**
 */
export interface ObliqueParameters {
    /**
     * the image pixel clicked
    */
    pixel: import("ol/coordinate").Coordinate;
    /**
     * true if the terrain could not be taken into account
    */
    estimate?: boolean | undefined;
}

/**
 */
export interface InteractionEvent extends MapEvent {
    type: EventType;
    /**
     * a potential feature at said location
    */
    feature?: undefined | import("ol").Feature<import("ol/geom/Geometry").default> | import("@vcmap/cesium").Cesium3DTileFeature | import("@vcmap/cesium").Cesium3DTilePointFeature;
    /**
     * if set to true, the event chain is interrupted
    */
    stopPropagation?: boolean | undefined;
    /**
     * additional parameters from oblique if obliquemode is active
    */
    obliqueParameters?: undefined | ObliqueParameters;
    /**
     * potential ray
    */
    ray?: import("@vcmap/cesium").Ray | undefined;
    /**
     * whether the position is exact, eg with translucentDepthPicking on
    */
    exactPosition?: boolean | undefined;
}

/**
 * An abstract interface for all interactions
 * @param [defaultActive = EventType.NONE] - A bitmask representing the default {@link EventType} to listen to
 * @param [defaultModificationKey = ModificationKeyType.NONE] - A bitmask representing the default {@link ModificationKeyType} keys to listen to
 * @param [defaultPointerKey = PointerKeyType.LEFT] - A bitmask representing the {@link PointerKeyType} pointer key to listen to
 */
export class AbstractInteraction {
    constructor(defaultActive?: number, defaultModificationKey?: number, defaultPointerKey?: number);
    /**
     * A unique identifier for this interaction
     */
    id: string;
    /**
     * The current active bitmask for {@link EventType}
     */
    active: number;
    /**
     * The current active {@link ModificationKeyType}
     */
    modificationKey: number;
    /**
     * The currently active {@link PointerKeyType}
     */
    pointerKey: number;
    /**
     * Main function, called when an event is raised for this interaction
     */
    pipe(event: InteractionEvent): Promise<InteractionEvent>;
    /**
     * Sets the interaction active.
     * Use boolean (true|false) to toggle default behavior.
     * Pass it a bitmask of {@link EventType}
     * to change the active state.
     * Call without arguments to reset the default active, modification key and pointer Key behavior
     */
    setActive(active?: boolean | number): void;
    /**
     * Sets the modification key to listen to or the default modification key if none is provided.
     */
    setModification(mod?: number): void;
    /**
     * Sets the pointer key for this interaction or the default pointer if none is provided.
     */
    setPointer(pointer?: number): void;
    /**
     * destroys the implementation, removing any created resources
     */
    destroy(): void;
}

export class CoordinateAtPixel extends AbstractInteraction {
    /**
     * A unique identifier for this interaction
     */
    id: string;
    /**
     * The current active bitmask for {@link EventType}
     */
    active: number;
    /**
     * The current active {@link ModificationKeyType}
     */
    modificationKey: number;
    /**
     * The currently active {@link PointerKeyType}
     */
    pointerKey: number;
}

export interface EventHandlerExclusiveInteraction {
    id: string;
    interactions: AbstractInteraction[];
    cb: ((...params: any[]) => void)[];
}

/**
 */
export interface MapEvent {
    pointerEvent: PointerEventType;
    map: VcsMap;
    windowPosition: import("@vcmap/cesium").Cartesian2;
    key: ModificationKeyType;
    pointer: PointerKeyType;
    /**
     * position in web mercator coordinates
    */
    position?: import("ol/coordinate").Coordinate | undefined;
    /**
     * position in web mercator coordinates or image coordinates in ObliqueMap Map Mode
    */
    positionOrPixel?: import("ol/coordinate").Coordinate | undefined;
    /**
     * vcs:undocumented
    */
    multipleTouch?: boolean | undefined;
    /**
     * vcs:undocumented
    */
    time?: number | null | undefined;
}

/**
 */
export interface LastClick {
    /**
     * vcs:undocumented
    */
    windowPosition: import("@vcmap/cesium").Cartesian2;
    /**
     * vcs:undocumented
    */
    time: number | null;
}

export class EventHandler {
    clickDuration: number;
    dragDuration: number;
    /**
     * Event called, when exclusive events are removed
     */
    exclusiveRemoved: VcsEvent<void>;
    /**
     * Event called, when exclusive events are added
     */
    exclusiveAdded: VcsEvent<void>;
    readonly positionInteraction: CoordinateAtPixel;
    readonly featureInteraction: FeatureAtPixelInteraction;
    readonly featureProviderInteraction: FeatureProviderInteraction;
    /**
     * A copy of all the EventHandler interactions
     */
    readonly interactions: AbstractInteraction[];
    /**
     * Add a dynamic interaction to the interaction chain. This is the default methodology for
     * user map interactions, such as drawing or measuring. If another exclusive interaction is added,
     * this interaction is removed and a provided callback is called. Use the id parameter to add multiple interactions
     * from the same source (if you don't wish to provide an {@link InteractionChain}
     * @param removed - the callback for when the interaction is forcefully removed.
     * @param [index = 3] - the position at which to push the interaction
     * @param [id] - an id to allow for multiple interactions to belong to the same exclusive registerer
     * @returns function to remove the interaction with. returns number of removed interactions (0|1)
     */
    addExclusiveInteraction(interaction: AbstractInteraction, removed: (...params: any[]) => any, index?: number, id?: string): (...params: any[]) => any;
    /**
     * Removes any exclusive listeners. Typically only called from the framework to ensure the pubsub listeners are consistent
     */
    removeExclusive(): void;
    /**
     * Adds an interaction permanently to the interaction chain. Only add non-interferring
     * interactions in such a fashion (for instance for displaying the cursor position)
     * @param [index = 3] - at what position this interaction should be added. By default, it is added after the featureProviderInteraction
     * @returns function to remove the interaction with. returns number of removed interactions (0|1)
     */
    addPersistentInteraction(interaction: AbstractInteraction, index?: number): (...params: any[]) => any;
    /**
     * Handles an event triggered by {@link VcsMap.pointerInteractionEvent}
     */
    handleMapEvent(event: MapEvent): void;
    /**
     * Destroys the event handler and its interaction chain.
     */
    destroy(): void;
}

export class FeatureAtPixelInteraction extends AbstractInteraction {
    /**
     * whether to pick translucent depth or not, defaults to true
     */
    pickTranslucent: boolean;
    /**
     * <i>Pulls</i> the picked position towards the camera position by this number
     */
    pullPickedPosition: number;
    /**
     * The number of pixels to take into account for picking features
     */
    hitTolerance: number;
    pickPosition: any;
    excludedPickPositionEvents: any;
    /**
     * A unique identifier for this interaction
     */
    id: string;
    /**
     * The current active bitmask for {@link EventType}
     */
    active: number;
    /**
     * The current active {@link ModificationKeyType}
     */
    modificationKey: number;
    /**
     * The currently active {@link PointerKeyType}
     */
    pointerKey: number;
}

export class FeatureProviderInteraction extends AbstractInteraction {
    /**
     * A unique identifier for this interaction
     */
    id: string;
    /**
     * The current active bitmask for {@link EventType}
     */
    active: number;
    /**
     * The current active {@link ModificationKeyType}
     */
    modificationKey: number;
    /**
     * The currently active {@link PointerKeyType}
     */
    pointerKey: number;
}

export class InteractionChain extends AbstractInteraction {
    constructor(chain?: AbstractInteraction[]);
    /**
     * The interactions to handle one after the other
     */
    chain: AbstractInteraction[];
    /**
     * Add an interaction to the chain. Optionally passing an index where to add the interaction to.
     */
    addInteraction(interaction: AbstractInteraction, index?: number): void;
    /**
     * Removes an interaction from the chain, returning the index from which it was removed
     */
    removeInteraction(interaction: AbstractInteraction): number;
    /**
     * A unique identifier for this interaction
     */
    id: string;
    /**
     * The current active bitmask for {@link EventType}
     */
    active: number;
    /**
     * The current active {@link ModificationKeyType}
     */
    modificationKey: number;
    /**
     * The currently active {@link PointerKeyType}
     */
    pointerKey: number;
}

/**
 * Provides inforamtion to other interaction plugins for creating bitmasks
 */
export class BitCounter {
    static interactionTypeCounter: any;
}

/**
 * Enumeration of modification key types
 */
export const enum ModificationKeyType {
    NONE,
    ALT,
    CTRL,
    SHIFT,
    ALL
}

/**
 * Enumeration of pointer event types
 */
export const enum EventType {
    NONE,
    CLICK,
    DBLCLICK,
    DRAG,
    DRAGSTART,
    DRAGEND,
    MOVE,
    DRAGEVENTS,
    CLICKMOVE,
    ALL
}

/**
 * Enumeration of pointer keys.
 */
export const enum PointerKeyType {
    LEFT,
    RIGHT,
    MIDDLE,
    ALL
}

/**
 * Enumeration of pointer key events.
 */
export const enum PointerEventType {
    DOWN,
    UP,
    MOVE
}

export const cesiumTilesetLastUpdated: symbol;

/**
 * @returns in mercator
 */
export function getExtentFromTileset(cesium3DTileset: import("@vcmap/cesium").Cesium3DTileset): import("ol/extent").Extent;



/**
 * represents the cesium implementation for a {@link CesiumTileset} layer.
 */
export class CesiumTilesetCesiumImpl extends LayerImplementation<CesiumMap> implements FeatureLayerImplementation {
    constructor(map: CesiumMap, options: CesiumTilesetImplementationOptions);
    static className: string;
    cesium3DTileset: import("@vcmap/cesium").Cesium3DTileset;
    tilesetOptions: any;
    splitDirection: import("@vcmap/cesium").SplitDirection;
    style: StyleItem;
    featureVisibility: FeatureVisibility;
    tilesetProperties: CesiumTilesetTilesetProperties[];
    modelMatrix: import("@vcmap/cesium").Matrix4;
    offset: import("ol/coordinate").Coordinate;
    initialize(): Promise<void>;
    updateModelMatrix(modelMatrix?: import("@vcmap/cesium").Matrix4): void;
    updateOffset(offset?: import("ol/coordinate").Coordinate): void;
    activate(): Promise<void>;
    deactivate(): void;
    updateStyle(style: StyleItem, silent?: boolean): void;
    updateSplitDirection(splitDirection: import("@vcmap/cesium").SplitDirection): void;
    applyStyle(tile: import("@vcmap/cesium").Cesium3DTile): void;
    styleContent(content: import("@vcmap/cesium").Cesium3DTileContent): void;
    destroy(): void;
}

export class ClusterContext {
    constructor(dataSource: import("@vcmap/cesium").CustomDataSource);
    entities: import("@vcmap/cesium").EntityCollection;
    featureToBillboardMap: Map<import("ol").Feature<import("ol/geom/Geometry").default>, import("@vcmap/cesium").Entity[]>;
    featureToLabelMap: Map<import("ol").Feature<import("ol/geom/Geometry").default>, import("@vcmap/cesium").Entity[]>;
    addPrimitives(primitives: (import("@vcmap/cesium").Primitive | import("@vcmap/cesium").GroundPrimitive | import("@vcmap/cesium").GroundPolylinePrimitive | import("@vcmap/cesium").ClassificationPrimitive | import("@vcmap/cesium").Model)[], feature: import("ol").Feature<import("ol/geom/Geometry").default>, allowPicking?: boolean): void;
    addBillboards(billboardOptions: object[], feature: import("ol").Feature<import("ol/geom/Geometry").default>, allowPicking?: boolean): void;
    addLabels(labelOptions: object[], feature: import("ol").Feature<import("ol/geom/Geometry").default>, allowPicking?: boolean): void;
    removeFeature(feature: import("ol").Feature<import("ol/geom/Geometry").default>): void;
    /**
     * Caches the current cesium resources for a feature, removing them from the feature map
     */
    createFeatureCache(feature: import("ol").Feature<import("ol/geom/Geometry").default>): VectorContextFeatureCache;
    clearFeatureCache(cache: VectorContextFeatureCache): void;
}

export class DataSourceCesiumImpl extends LayerImplementation<CesiumMap> {
    constructor(map: CesiumMap, options: DataSourceImplementationOptions);
    static className: string;
    dataSource: import("@vcmap/cesium").CustomDataSource | import("@vcmap/cesium").CzmlDataSource;
    entities: import("@vcmap/cesium").EntityCollection;
    clock: import("@vcmap/cesium").DataSourceClock | undefined;
    initialize(): Promise<void>;
    activate(): Promise<void>;
    deactivate(): void;
    flyToEntity(id: string): void;
    destroy(): void;
}

/**
 * represents a specific OpenStreetMapLayer layer for cesium.
 */
export class OpenStreetMapCesiumImpl extends RasterLayerCesiumImpl {
}



/**
 * RasterLayer implementation for {@link Openlayers}
 */
export class RasterLayerCesiumImpl extends LayerImplementation<CesiumMap> implements RasterLayerImplementation {
    constructor(map: CesiumMap, options: RasterLayerImplementationOptions);
    cesiumLayer: import("@vcmap/cesium").ImageryLayer | null;
    splitDirection: import("@vcmap/cesium").SplitDirection;
    minLevel: number;
    maxLevel: number;
    tilingSchema: string;
    extent: Extent;
    opacity: number;
    initialize(): Promise<void>;
    updateSplitDirection(splitDirection: import("@vcmap/cesium").SplitDirection): void;
    getCesiumLayer(): import("@vcmap/cesium").ImageryLayer;
    activate(): Promise<void>;
    deactivate(): void;
    updateOpacity(opacity: number): void;
    destroy(): void;
}

/**
 * represents a specific Cesium SingleTileImagery Layer class.
 */
export class SingleImageCesiumImpl extends RasterLayerCesiumImpl {
    constructor(map: CesiumMap, options: SingleImageImplementationOptions);
    credit: string;
    cesiumLayer: import("@vcmap/cesium").ImageryLayer | null;
    splitDirection: import("@vcmap/cesium").SplitDirection;
    minLevel: number;
    maxLevel: number;
    tilingSchema: string;
    extent: Extent;
    opacity: number;
}

/**
 * TerrainLayer implementation for {@link CesiumMap}
 */
export class TerrainCesiumImpl extends LayerImplementation<CesiumMap> {
    constructor(map: CesiumMap, options: TerrainImplementationOptions);
    requestVertexNormals: boolean;
    requestWaterMask: boolean;
    initialize(): Promise<void>;
    activate(): Promise<void>;
    deactivate(): void;
    destroy(): void;
}

/**
 * TmsLayer implementation for {@link CesiumMap}.
 */
export class TmsCesiumImpl extends RasterLayerCesiumImpl {
    constructor(map: CesiumMap, options: TMSImplementationOptions);
    format: string;
    cesiumLayer: import("@vcmap/cesium").ImageryLayer | null;
    splitDirection: import("@vcmap/cesium").SplitDirection;
    minLevel: number;
    maxLevel: number;
    tilingSchema: string;
    extent: Extent;
    opacity: number;
}



/**
 * represents a specific vector layer for cesium.
 */
export class VectorCesiumImpl extends LayerImplementation<CesiumMap> implements FeatureLayerImplementation {
    constructor(map: CesiumMap, options: VectorImplementationOptions);
    vectorProperties: VectorProperties;
    source: import("ol/source").Vector<import("ol/geom/Geometry").default>;
    style: StyleItem;
    featureVisibility: FeatureVisibility;

    protected _context: VectorContext | ClusterContext | null;
    protected _setupContext(cesiumMap: CesiumMap): Promise<void>;
    initialize(): Promise<void>;
    /**
     * Forces a complete re-render of all features.
     */
    refresh(): void;
    activate(): Promise<void>;
    deactivate(): void;
    updateStyle(style: StyleItem, silent?: boolean): void;
    protected _destroyCollection(): void;
    destroy(): void;
}

export interface VectorContextFeatureCache {
    primitives?: (import("@vcmap/cesium").Primitive | import("@vcmap/cesium").GroundPrimitive | import("@vcmap/cesium").GroundPolylinePrimitive | import("@vcmap/cesium").ClassificationPrimitive | import("@vcmap/cesium").Model)[] | undefined;
    billboards?: (import("@vcmap/cesium").Billboard | import("@vcmap/cesium").Entity)[] | undefined;
    labels?: (import("@vcmap/cesium").Label | import("@vcmap/cesium").Entity)[] | undefined;
}

export function setReferenceForPicking(feature: import("ol").Feature<import("ol/geom/Geometry").default>, primitive: import("@vcmap/cesium").Primitive | import("@vcmap/cesium").GroundPrimitive | import("@vcmap/cesium").GroundPolylinePrimitive | import("@vcmap/cesium").ClassificationPrimitive | import("@vcmap/cesium").Label | import("@vcmap/cesium").Billboard | import("@vcmap/cesium").Entity | import("@vcmap/cesium").Model): void;

export function removeArrayFromCollection(collection: import("@vcmap/cesium").PrimitiveCollection | import("@vcmap/cesium").BillboardCollection | import("@vcmap/cesium").LabelCollection | import("@vcmap/cesium").EntityCollection, array?: (import("@vcmap/cesium").Primitive | import("@vcmap/cesium").GroundPrimitive | import("@vcmap/cesium").GroundPolylinePrimitive | import("@vcmap/cesium").ClassificationPrimitive | import("@vcmap/cesium").Billboard | import("@vcmap/cesium").Label | import("@vcmap/cesium").Entity | import("@vcmap/cesium").Model)[]): void;

export function removeFeatureFromMap(feature: import("ol").Feature<import("ol/geom/Geometry").default>, featuresMap: Map<import("ol").Feature<import("ol/geom/Geometry").default>, (import("@vcmap/cesium").Primitive | import("@vcmap/cesium").GroundPrimitive | import("@vcmap/cesium").GroundPolylinePrimitive | import("@vcmap/cesium").ClassificationPrimitive | import("@vcmap/cesium").Billboard | import("@vcmap/cesium").Label | import("@vcmap/cesium").Entity | import("@vcmap/cesium").Model)[]>, primitiveCollection: import("@vcmap/cesium").PrimitiveCollection | import("@vcmap/cesium").BillboardCollection | import("@vcmap/cesium").LabelCollection | import("@vcmap/cesium").EntityCollection): void;

export function addPrimitiveToContext(primitives: (import("@vcmap/cesium").Primitive | import("@vcmap/cesium").GroundPrimitive | import("@vcmap/cesium").GroundPolylinePrimitive | import("@vcmap/cesium").ClassificationPrimitive | import("@vcmap/cesium").Entity.ConstructorOptions | import("@vcmap/cesium").Model | object)[], feature: import("ol").Feature<import("ol/geom/Geometry").default>, allowPicking: boolean, primitiveCollection: import("@vcmap/cesium").BillboardCollection | import("@vcmap/cesium").LabelCollection | import("@vcmap/cesium").PrimitiveCollection | import("@vcmap/cesium").EntityCollection, featureMap: Map<import("ol").Feature<import("ol/geom/Geometry").default>, (import("@vcmap/cesium").Billboard | import("@vcmap/cesium").Label | import("@vcmap/cesium").Primitive | import("@vcmap/cesium").GroundPrimitive | import("@vcmap/cesium").GroundPolylinePrimitive | import("@vcmap/cesium").ClassificationPrimitive | import("@vcmap/cesium").Entity | import("@vcmap/cesium").Model)[]>): void;

export class VectorContext {
    constructor(scene: import("@vcmap/cesium").Scene, rootCollection: import("@vcmap/cesium").PrimitiveCollection);
    primitives: import("@vcmap/cesium").PrimitiveCollection;
    billboards: import("@vcmap/cesium").BillboardCollection;
    labels: import("@vcmap/cesium").LabelCollection;
    featureToPrimitiveMap: Map<import("ol").Feature<import("ol/geom/Geometry").default>, (import("@vcmap/cesium").Primitive | import("@vcmap/cesium").GroundPrimitive | import("@vcmap/cesium").GroundPolylinePrimitive | import("@vcmap/cesium").ClassificationPrimitive | import("@vcmap/cesium").Model)[]>;
    featureToBillboardMap: Map<import("ol").Feature<import("ol/geom/Geometry").default>, import("@vcmap/cesium").Billboard[]>;
    featureToLabelMap: Map<import("ol").Feature<import("ol/geom/Geometry").default>, import("@vcmap/cesium").Label[]>;
    addPrimitives(primitives: (import("@vcmap/cesium").Primitive | import("@vcmap/cesium").GroundPrimitive | import("@vcmap/cesium").GroundPolylinePrimitive | import("@vcmap/cesium").ClassificationPrimitive | import("@vcmap/cesium").Model)[], feature: import("ol").Feature<import("ol/geom/Geometry").default>, allowPicking?: boolean): void;
    addBillboards(billboardOptions: object[], feature: import("ol").Feature<import("ol/geom/Geometry").default>, allowPicking?: boolean): void;
    addLabels(labelOptions: object[], feature: import("ol").Feature<import("ol/geom/Geometry").default>, allowPicking?: boolean): void;
    removeFeature(feature: import("ol").Feature<import("ol/geom/Geometry").default>): void;
    /**
     * Caches the current cesium resources for a feature, removing them from the feature map
     */
    createFeatureCache(feature: import("ol").Feature<import("ol/geom/Geometry").default>): VectorContextFeatureCache;
    clearFeatureCache(cache: VectorContextFeatureCache): void;
    /**
     * Clears all collections and maps
     */
    clear(): void;
}



/**
 * represents a rasterized tiled vector layer implementation for cesium.
 */
export class VectorRasterTileCesiumImpl extends RasterLayerCesiumImpl implements VectorTileImplementation {
    constructor(map: CesiumMap, options: VectorTileImplementationOptions);
    tileProvider: TileProvider;
    tileSize: import("ol/size").Size;
    imageryProvider: VectorTileImageryProvider;
    /**
     * rerenders the specified tiles
     * rendering happens async
     */
    updateTiles(tileIds: string[]): void;
    updateStyle(style: StyleItem, silent?: boolean): void;
    cesiumLayer: import("@vcmap/cesium").ImageryLayer | null;
    splitDirection: import("@vcmap/cesium").SplitDirection;
    minLevel: number;
    maxLevel: number;
    tilingSchema: string;
    extent: Extent;
    opacity: number;
}

export function toContext(extent: import("ol/extent").Extent, center: import("ol/coordinate").Coordinate, context: any, tileSize: import("ol/size").Size): import("ol").CanvasTileRenderer;

/**
 * creates a canvas and draws the features on the canvas;
 */
export function getCanvasFromFeatures(features: import("ol").Feature<import("ol/geom/Geometry").default>[], extent: import("ol/extent").Extent, center: import("@vcmap/cesium").Cartographic, tileSize: import("ol/size").Size): HTMLCanvasElement;

export interface VectorTileImageryProviderOptions {
    tileProvider: TileProvider;
    tileSize: import("ol/size").Size;
}

/**
 * implementation of Cesium ImageryProvider Interface
 */
export class VectorTileImageryProvider {
    constructor(options: VectorTileImageryProviderOptions);
    tileProvider: TileProvider;
    emptyCanvas: HTMLCanvasElement;
    minLevel: number;
    maxLevel: number;

    ready: any;
    readyPromise: any;
    rectangle: any;
    tileWidth: any;
    tileHeight: any;
    maximumLevel: any;
    minimumLevel: any;
    tilingScheme: any;
    errorEvent: any;
    /**
     * Requests the image for a given tile.  This function should
     * not be called before {@link TileCoordinatesImageryProvider#ready} returns true.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level.
     * @returns A promise for the image that will resolve when the image is available, or
     *          undefined if there are too many active requests to the server, and the request
     *          should be retried later.  The resolved image may be either an
     *          Image or a Canvas DOM object.
     */
    requestImage(x: number, y: number, level: number): Promise<HTMLImageElement | HTMLCanvasElement>;
}

/**
 * represents a specific Cesium WmsCesiumImpl Layer class.
 */
export class WmsCesiumImpl extends RasterLayerCesiumImpl {
    constructor(map: CesiumMap, options: WMSImplementationOptions);
    parameters: {
        [key: string]: any;
    };
    highResolution: boolean;
    tileSize: import("ol/size").Size;
    cesiumLayer: import("@vcmap/cesium").ImageryLayer | null;
    splitDirection: import("@vcmap/cesium").SplitDirection;
    minLevel: number;
    maxLevel: number;
    tilingSchema: string;
    extent: Extent;
    opacity: number;
}

/**
 * represents a specific WmtsLayer Implementation for {@link CesiumMap}.
 */
export class WmtsCesiumImpl extends RasterLayerCesiumImpl {
    constructor(map: CesiumMap, options: WMTSImplementationOptions);
    layer: string;
    style: string;
    format: string;
    tileMatrixSetID: string;
    tileSize: import("ol/size").Size;
    numberOfLevelZeroTilesX: number;
    numberOfLevelZeroTilesY: number;
    matrixIds: string[];
    cesiumLayer: import("@vcmap/cesium").ImageryLayer | null;
    splitDirection: import("@vcmap/cesium").SplitDirection;
    minLevel: number;
    maxLevel: number;
    tilingSchema: string;
    extent: Extent;
    opacity: number;
}

/**
 */
export interface CesiumTilesetOptions extends LayerOptions {
    /**
     * relates inversely to the depth over which the layer is activated
    */
    screenSpaceError?: number | undefined;
    /**
     * relates inversely to the depth over which the layer is activated
    */
    screenSpaceErrorMobile?: number | undefined;
    /**
     * sets the cesium maximumMemoryUsage Parameter (Is when the cached tiles exceed this value cesium starts to clear the cached tiles)
    */
    maximumMemoryUsage?: number | undefined;
    tilesetOptions?: any | undefined;
    highlightStyle?: VectorStyleItem | VectorStyleItemOptions | undefined;
    featureVisibility?: FeatureVisibility | undefined;
    /**
     * either 'left' or 'right', if omitted none is applied
    */
    splitDirection?: string | undefined;
    /**
     * an offset of x, y, z. x and y in degrees longitude/latitude respectively
    */
    offset?: import("ol/coordinate").Coordinate | undefined;
}

export interface CesiumTilesetTilesetProperties {
    key: string | symbol;
    value: any;
}

export interface CesiumTilesetImplementationOptions extends FeatureLayerImplementationOptions {
    tilesetOptions?: any | undefined;
    splitDirection: import("@vcmap/cesium").SplitDirection;
    tilesetProperties?: CesiumTilesetTilesetProperties[] | undefined;
    modelMatrix?: import("@vcmap/cesium").Matrix4 | undefined;
    offset?: import("ol/coordinate").Coordinate | undefined;
}



/**
 * represents a specific Building layer for cesium.
 */
export class CesiumTilesetLayer extends FeatureLayer implements SplitLayer {
    constructor(options: CesiumTilesetOptions);
    static className: string;
    static getDefaultOptions(): CesiumTilesetOptions;
    highlightStyle: VectorStyleItem;
    screenSpaceError: number;
    screenSpaceErrorMobile: number;
    maximumMemoryUsage: number;
    tilesetOptions: any;

    /**
     * raised if the split direction changes, is passed the split direction as its only argument
     */
    splitDirectionChanged: VcsEvent<import("@vcmap/cesium").SplitDirection>;
    modelMatrix: any;
    offset: any;
    splitDirection: any;
    /**
     * set the maximum screenspace error of this layer
     */
    setMaximumScreenSpaceError(value: number): void;
    /**
     * An event, called when the style of the layer changes. Is passed the new style item as its value.
     */
    styleChanged: VcsEvent<StyleItem>;
    /**
     * a height offset for rendering of a balloon for a feature of this layer.
     */
    balloonHeightOffset: number;
    /**
     * FeatureVisibility tracks the highlighting and hiding of features on this layer
     */
    featureVisibility: FeatureVisibility;
    /**
     * The style the layer had at construction
     */
    readonly defaultStyle: StyleItem;
    /**
     * style, use setStyle to change
     */
    readonly style: StyleItem;
    /**
     * Generic properties to be added to each feature. Use assignGenericFeatureProperties to change them.
     */
    readonly genericFeatureProperties: any;
    /**
     * Metadata on the extent of the data in this layer. Depending on the implementation, data is only requested
     * for this extent (e.g. {@see RasterLayer})
     */
    extent: Extent | null;
    /**
     * Whether this layer should be active on startup or not. Relevant for creating links.
     */
    activeOnStartup: boolean;
    /**
     * the names of the maps this layer is shown, all if empty
     */
    mapNames: string[];
    /**
     * The class names of the supported maps.
     */
    protected _supportedMaps: string[];
    /**
     * Called when the zIndex of this layer is changed. Is passed the new zIndex as its only argument.
     */
    zIndexChanged: VcsEvent<number>;
    /**
     * array of object Ids which should be hidden within the context of the layers layerCollection, if this layer is active
     */
    hiddenObjectIds: string[];
    /**
     * event raised if the exclusives group of the layer changes. is passed the array of exclusive groups as its only argument
     */
    exclusiveGroupsChanged: VcsEvent<(string | symbol)[]>;
    globalHider: GlobalHider;
    copyright: CopyrightOptions | undefined;
    /**
     * Event raised, if the layers state changes. Is passed the LayerState as its only parameter
     */
    stateChanged: VcsEvent<LayerState>;
    /**
     * An optional feature provider to provider features based on click events.
     */
    featureProvider: AbstractFeatureProvider;
    /**
     * True if this layer has been initialized, typically after its first activation.
     */
    readonly initialized: boolean;
    readonly active: boolean;
    readonly loading: boolean;
    readonly state: LayerState;
    allowPicking: boolean;
    /**
     * A layers url, should on be configured, else an empty string
     */
    url: string;
    /**
     * Indicates, that this layer is part of an exclusiveGroup
     */
    readonly exclusive: boolean;
    /**
     * An array of arbitrary exclusive groups
     */
    readonly exclusiveGroups: any;
    zIndex: number;
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
}

export interface CzmlOptions extends DataSourceOptions {
    sourceUri?: string | undefined;
}

export class CzmlLayer extends DataSourceLayer {
    constructor(options: CzmlOptions);
    static getDefaultOptions(): CzmlOptions;
    sourceUri: string | null;


    /**
     * A Promise resolving with the DataSourceLayer on load
     */
    loaded: Promise<void>;
    /**
     * The entities of this layer. Use the `addEntity` API to add Enitities to ensure interoperability with vcm interfaces
     */
    entities: import("@vcmap/cesium").EntityCollection;
    clock: import("@vcmap/cesium").DataSourceClock | undefined;
    /**
     * The feature visibility of this layer. NOTE: Entities cannot be highlighted at this moment.
     */
    featureVisibility: FeatureVisibility;
    /**
     * Metadata on the extent of the data in this layer. Depending on the implementation, data is only requested
     * for this extent (e.g. {@see RasterLayer})
     */
    extent: Extent | null;
    /**
     * Whether this layer should be active on startup or not. Relevant for creating links.
     */
    activeOnStartup: boolean;
    /**
     * the names of the maps this layer is shown, all if empty
     */
    mapNames: string[];
    /**
     * The class names of the supported maps.
     */
    protected _supportedMaps: string[];
    /**
     * Called when the zIndex of this layer is changed. Is passed the new zIndex as its only argument.
     */
    zIndexChanged: VcsEvent<number>;
    /**
     * array of object Ids which should be hidden within the context of the layers layerCollection, if this layer is active
     */
    hiddenObjectIds: string[];
    /**
     * event raised if the exclusives group of the layer changes. is passed the array of exclusive groups as its only argument
     */
    exclusiveGroupsChanged: VcsEvent<(string | symbol)[]>;
    globalHider: GlobalHider;
    copyright: CopyrightOptions | undefined;
    /**
     * Event raised, if the layers state changes. Is passed the LayerState as its only parameter
     */
    stateChanged: VcsEvent<LayerState>;
    /**
     * An optional feature provider to provider features based on click events.
     */
    featureProvider: AbstractFeatureProvider;
    /**
     * True if this layer has been initialized, typically after its first activation.
     */
    readonly initialized: boolean;
    readonly active: boolean;
    readonly loading: boolean;
    readonly state: LayerState;
    allowPicking: boolean;
    /**
     * A layers url, should on be configured, else an empty string
     */
    url: string;
    /**
     * Indicates, that this layer is part of an exclusiveGroup
     */
    readonly exclusive: boolean;
    /**
     * An array of arbitrary exclusive groups
     */
    readonly exclusiveGroups: any;
    zIndex: number;
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
}

export interface DataSourceOptions extends LayerOptions {
    genericFeatureProperties?: any | undefined;
}

export interface DataSourcePickedObject {
    id: import("@vcmap/cesium").Entity;
    clickedPosition: ClickPosition;
    attributes: any;
}

export interface DataSourceImplementationOptions extends LayerImplementationOptions {
    entities: import("@vcmap/cesium").EntityCollection;
    clock?: import("@vcmap/cesium").DataSourceClock | undefined;
}

/**
 * Represents a layer of Cesium.Entity
 */
export class DataSourceLayer extends Layer {
    constructor(options: DataSourceOptions);
    static getDefaultOptions(): DataSourceOptions;
    /**
     * The entities of this layer. Use the `addEntity` API to add Enitities to ensure interoperability with vcm interfaces
     */
    entities: import("@vcmap/cesium").EntityCollection;
    clock: import("@vcmap/cesium").DataSourceClock | undefined;
    /**
     * The feature visibility of this layer. NOTE: Entities cannot be highlighted at this moment.
     */
    featureVisibility: FeatureVisibility;
    /**
     * adds an entity
     * @param options - Cesium Entity options or the entity
     * @param [attributes] - a set of properties, typically used for rendering a balloon
     * @param [allowPicking] - whether to override the layers allowPicking setting for this entity
     * @returns the entities id
     */
    addEntity(options: import("@vcmap/cesium").Entity.ConstructorOptions | import("@vcmap/cesium").Entity, attributes?: any, allowPicking?: boolean): null | string;
    /**
     * Zooms to an entity with the given id
     */
    flyToEntity(id: string): void;
    /**
     * Removes an entity from this layer by id
     */
    removeEntityById(id: string): void;
    objectClickedHandler(object: DataSourcePickedObject): any;
    getGenericFeatureFromClickedObject(object: DataSourcePickedObject): GenericFeature;
    /**
     * Metadata on the extent of the data in this layer. Depending on the implementation, data is only requested
     * for this extent (e.g. {@see RasterLayer})
     */
    extent: Extent | null;
    /**
     * Whether this layer should be active on startup or not. Relevant for creating links.
     */
    activeOnStartup: boolean;
    /**
     * the names of the maps this layer is shown, all if empty
     */
    mapNames: string[];
    /**
     * The class names of the supported maps.
     */
    protected _supportedMaps: string[];
    /**
     * Called when the zIndex of this layer is changed. Is passed the new zIndex as its only argument.
     */
    zIndexChanged: VcsEvent<number>;
    /**
     * array of object Ids which should be hidden within the context of the layers layerCollection, if this layer is active
     */
    hiddenObjectIds: string[];
    /**
     * event raised if the exclusives group of the layer changes. is passed the array of exclusive groups as its only argument
     */
    exclusiveGroupsChanged: VcsEvent<(string | symbol)[]>;
    globalHider: GlobalHider;
    copyright: CopyrightOptions | undefined;
    /**
     * Event raised, if the layers state changes. Is passed the LayerState as its only parameter
     */
    stateChanged: VcsEvent<LayerState>;
    /**
     * An optional feature provider to provider features based on click events.
     */
    featureProvider: AbstractFeatureProvider;
    /**
     * True if this layer has been initialized, typically after its first activation.
     */
    readonly initialized: boolean;
    readonly active: boolean;
    readonly loading: boolean;
    readonly state: LayerState;
    allowPicking: boolean;
    /**
     * A layers url, should on be configured, else an empty string
     */
    url: string;
    /**
     * Indicates, that this layer is part of an exclusiveGroup
     */
    readonly exclusive: boolean;
    /**
     * An array of arbitrary exclusive groups
     */
    readonly exclusiveGroups: any;
    zIndex: number;
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
}

/**
 */
export interface FeatureLayerOptions extends LayerOptions {
    style?: DeclarativeStyleItemOptions | VectorStyleItemOptions | StyleItem | undefined;
    /**
     * properties to add to generic features, eg for display in the balloon
    */
    genericFeatureProperties?: any | undefined;
    balloonHeightOffset?: number;
    /**
     * vcs:undocumented
    */
    featureVisibility?: FeatureVisibility | undefined;
}

export interface FeatureLayerImplementationOptions extends LayerImplementationOptions {
    featureVisibility: FeatureVisibility;
    style: StyleItem;
}

export interface FeatureLayerImplementation extends LayerImplementation<VcsMap> {
    updateStyle: (...params: any[]) => any;
}

/**
 * Base class for all layers representing features, e.g. VectorLayer, Buildings, POIs
 */
export class FeatureLayer extends Layer {
    constructor(options: FeatureLayerOptions);
    static className: string;
    static getDefaultOptions(): FeatureLayerOptions;
    /**
     * An event, called when the style of the layer changes. Is passed the new style item as its value.
     */
    styleChanged: VcsEvent<StyleItem>;
    /**
     * a height offset for rendering of a balloon for a feature of this layer.
     */
    balloonHeightOffset: number;
    /**
     * FeatureVisibility tracks the highlighting and hiding of features on this layer
     */
    featureVisibility: FeatureVisibility;
    /**
     * The style the layer had at construction
     */
    readonly defaultStyle: StyleItem;
    /**
     * style, use setStyle to change
     */
    readonly style: StyleItem;
    /**
     * Generic properties to be added to each feature. Use assignGenericFeatureProperties to change them.
     */
    readonly genericFeatureProperties: any;
    objectClickedHandler(object: any | import("ol").Feature<import("ol/geom/Geometry").default> | import("@vcmap/cesium").Cesium3DTilePointFeature | import("@vcmap/cesium").Cesium3DTileFeature | DataSourcePickedObject): any;
    /**
     * This is called by the selectBehavior to create generic features from clicked objects
     * needs to be implemented by each layer which has clickable objects
     */
    getGenericFeatureFromClickedObject(object: any | VectorClickedObject | import("ol").Feature<import("ol/geom/Geometry").default>): GenericFeature;
    /**
     * Set properties, which are always added to the generic object, eg. for use in balloons
     */
    assignGenericFeatureProperties(properties: any): void;
    getStyleOrDefaultStyle(styleOptions?: DeclarativeStyleItemOptions | VectorStyleItemOptions | StyleItem, defaultStyle?: VectorStyleItem | DeclarativeStyleItem): StyleItem;
    /**
     * Sets the style based on a styleName on a layer
     */
    setStyle(style: import("ol/style/Style").default | import("ol/style/Style").StyleFunction | StyleItem, silent?: boolean): void;
    /**
     * Clears the style of this layer
     */
    clearStyle(): void;
    /**
     * Metadata on the extent of the data in this layer. Depending on the implementation, data is only requested
     * for this extent (e.g. {@see RasterLayer})
     */
    extent: Extent | null;
    /**
     * Whether this layer should be active on startup or not. Relevant for creating links.
     */
    activeOnStartup: boolean;
    /**
     * the names of the maps this layer is shown, all if empty
     */
    mapNames: string[];
    /**
     * The class names of the supported maps.
     */
    protected _supportedMaps: string[];
    /**
     * Called when the zIndex of this layer is changed. Is passed the new zIndex as its only argument.
     */
    zIndexChanged: VcsEvent<number>;
    /**
     * array of object Ids which should be hidden within the context of the layers layerCollection, if this layer is active
     */
    hiddenObjectIds: string[];
    /**
     * event raised if the exclusives group of the layer changes. is passed the array of exclusive groups as its only argument
     */
    exclusiveGroupsChanged: VcsEvent<(string | symbol)[]>;
    globalHider: GlobalHider;
    copyright: CopyrightOptions | undefined;
    /**
     * Event raised, if the layers state changes. Is passed the LayerState as its only parameter
     */
    stateChanged: VcsEvent<LayerState>;
    /**
     * An optional feature provider to provider features based on click events.
     */
    featureProvider: AbstractFeatureProvider;
    /**
     * True if this layer has been initialized, typically after its first activation.
     */
    readonly initialized: boolean;
    readonly active: boolean;
    readonly loading: boolean;
    readonly state: LayerState;
    allowPicking: boolean;
    /**
     * A layers url, should on be configured, else an empty string
     */
    url: string;
    /**
     * Indicates, that this layer is part of an exclusiveGroup
     */
    readonly exclusive: boolean;
    /**
     * An array of arbitrary exclusive groups
     */
    readonly exclusiveGroups: any;
    zIndex: number;
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
}

/**
 */
export interface FeatureStoreStaticRepresentation {
    /**
     * 3D static representation of this layer
    */
    threeDim?: string | undefined;
    /**
     * 2D static representation for this layer
    */
    twoDim?: string | undefined;
}

/**
 */
export interface FeatureStoreFeature {
    /**
     * the mongo id
    */
    id: string;
    /**
     * the properties bag
    */
    properties: any;
    geometry: any;
    vcsMeta?: any | undefined;
    state: FeatureStoreLayerState;
    /**
     * the featureType
    */
    type: string;
}

/**
 * For further details see: {@link http://gitlab/vcsuite/virtualcityMAP/wikis/featureStore/layerSchema}
 */
export interface FeatureStoreLayerSchema extends VectorOptions {
    /**
     * layer mongo id
    */
    id: string;
    type: string;
    featureType: string;
    /**
     * URLs to static representations for 2D and 3D maps
    */
    staticRepresentation?: FeatureStoreStaticRepresentation | undefined;
    /**
     * an array of IDs of features to hide from the static representation
    */
    hiddenStaticFeatureIds: (string | number)[];
    /**
     * the array of features to represent dynamic features
    */
    features: FeatureStoreFeature[];
    /**
     * vector style implemented by the map and base64-encoded png icons used for custom styles
    */
    vcsMeta: VcsMeta;
}

/**
 */
export interface FeatureStoreOptions extends FeatureStoreLayerSchema {
    /**
     * injected function for fetching dynamic features from a remote FeatureStoreLayer server
    */
    injectedFetchDynamicFeatureFunc?: ((...params: any[]) => any) | undefined;
}

export const isTiledFeature: symbol;

/**
 * FeatureStoreLayer Layer
 */
export class FeatureStoreLayer extends VectorLayer {
    constructor(options: FeatureStoreOptions);
    static getDefaultOptions(): FeatureStoreOptions;
    /**
     * Feature Store layers have feature UUIDs by design
     */
    hasFeatureUUID: boolean;
    layerId: string;
    staticRepresentation: FeatureStoreStaticRepresentation;
    hiddenStaticFeatureIds: Set<string | number>;
    changeTracker: FeatureStoreLayerChanges;
    vcsMeta: VcsMeta;
    screenSpaceErrorMobile: number;
    screenSpaceError: number;
    /**
     * a function to retrieve a single feature from the server
     */
    injectedFetchDynamicFeatureFunc: ((...params: any[]) => any) | undefined;
    setEditing(symbol: symbol, featureType?: number): void;
    /**
     * set the maximum screen space error of this layer
     */
    setMaximumScreenSpaceError(value: number): void;
    /**
     * switch an array of static features to dynamic features
     * This is done by hiding the static features and adding their dynamic counterparts to the FeatureStoreLayer layer
     * @param [featureId] - input static feature ID
     */
    switchStaticFeatureToDynamic(featureId?: string | number): Promise<import("ol").Feature<import("ol/geom/Geometry").default>>;
    /**
     * removes a static feature from featureStore layer
     */
    removeStaticFeature(featureId: string): void;
    /**
     * Resets a feature which used to be static but is now dynamic. called from featureStoreChanges API.
     */
    resetStaticFeature(featureId: string | number): void;
    source: import("ol/source").Vector<import("ol/geom/Geometry").default>;
    projection: Projection;
    maxResolution: number;
    minResolution: number;
    dontUseTerrainForOblique: boolean;
    highlightStyle: VectorStyleItem;
    /**
     * If true, the cesium synchronizers are destroyed on map change
     */
    isDynamic: boolean;
    vectorProperties: VectorProperties;
    allowPicking: boolean;
    visibility: boolean;
    /**
     * An event, called when the style of the layer changes. Is passed the new style item as its value.
     */
    styleChanged: VcsEvent<StyleItem>;
    /**
     * a height offset for rendering of a balloon for a feature of this layer.
     */
    balloonHeightOffset: number;
    /**
     * FeatureVisibility tracks the highlighting and hiding of features on this layer
     */
    featureVisibility: FeatureVisibility;
    /**
     * The style the layer had at construction
     */
    readonly defaultStyle: StyleItem;
    /**
     * style, use setStyle to change
     */
    readonly style: StyleItem;
    /**
     * Generic properties to be added to each feature. Use assignGenericFeatureProperties to change them.
     */
    readonly genericFeatureProperties: any;
    /**
     * Metadata on the extent of the data in this layer. Depending on the implementation, data is only requested
     * for this extent (e.g. {@see RasterLayer})
     */
    extent: Extent | null;
    /**
     * Whether this layer should be active on startup or not. Relevant for creating links.
     */
    activeOnStartup: boolean;
    /**
     * the names of the maps this layer is shown, all if empty
     */
    mapNames: string[];
    /**
     * The class names of the supported maps.
     */
    protected _supportedMaps: string[];
    /**
     * Called when the zIndex of this layer is changed. Is passed the new zIndex as its only argument.
     */
    zIndexChanged: VcsEvent<number>;
    /**
     * array of object Ids which should be hidden within the context of the layers layerCollection, if this layer is active
     */
    hiddenObjectIds: string[];
    /**
     * event raised if the exclusives group of the layer changes. is passed the array of exclusive groups as its only argument
     */
    exclusiveGroupsChanged: VcsEvent<(string | symbol)[]>;
    globalHider: GlobalHider;
    copyright: CopyrightOptions | undefined;
    /**
     * Event raised, if the layers state changes. Is passed the LayerState as its only parameter
     */
    stateChanged: VcsEvent<LayerState>;
    /**
     * An optional feature provider to provider features based on click events.
     */
    featureProvider: AbstractFeatureProvider;
    /**
     * True if this layer has been initialized, typically after its first activation.
     */
    readonly initialized: boolean;
    readonly active: boolean;
    readonly loading: boolean;
    readonly state: LayerState;
    /**
     * A layers url, should on be configured, else an empty string
     */
    url: string;
    /**
     * Indicates, that this layer is part of an exclusiveGroup
     */
    readonly exclusive: boolean;
    /**
     * An array of arbitrary exclusive groups
     */
    readonly exclusiveGroups: any;
    zIndex: number;
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
}

export interface FeatureStoreTrackResults {
    add: import("ol").Feature<import("ol/geom/Geometry").default>[];
    edit: import("ol").Feature<import("ol/geom/Geometry").default>[];
    remove: import("ol").Feature<import("ol/geom/Geometry").default>[];
}

export interface FeatureStoreChangesListeners {
    addfeature: import("ol/events").EventsKey | import("ol/events").EventsKey[] | null;
    changefeature: import("ol/events").EventsKey | import("ol/events").EventsKey[] | null;
    removefeature: import("ol/events").EventsKey | import("ol/events").EventsKey[] | null;
}

export interface FeatureStoreChangesValues {
    changed: boolean;
}

export interface CommitAction {
    action: string;
    feature: import("ol/format/GeoJSON").GeoJSONFeature;
    original: import("ol").Feature<import("ol/geom/Geometry").default>;
    success: (...params: any[]) => any;
}

/**
 * do not construct directly, use the layers .changeTracker instead
 */
export class FeatureStoreLayerChanges extends VcsObject {
    constructor(layer: FeatureStoreLayer);
    layer: FeatureStoreLayer;





    values: FeatureStoreChangesValues;
    /**
     * Whether changes are being tracked or not
     */
    readonly active: any;
    /**
     * starts tracking changes on the layer
     * starts tracking changes on the feature store layer
     */
    track(): void;
    getChanges(): FeatureStoreTrackResults;
    /**
     * commits the changes to the provided url. url should contain accessTokens and point to a featureStore layers bulk operation endpoint
     */
    commitChanges(url: string): Promise<void>;
    /**
     * resets all changes since the last commit or the beginning of tracking
     */
    reset(): Promise<void>;
    /**
     * stops tracking changes on the feature store layer
     */
    unTrack(): void;
    /**
     * pauses the tracking of the given event, but does not reset features
     * @param event - one of: addfeature, changefeature or removefeature
     */
    pauseTracking(event: string): void;
    /**
     * tracks the change of removing a static feature
     */
    removeFeature(feature: import("ol").Feature<import("ol/geom/Geometry").default>): void;
    /**
     * adds an addition to the tracker. prefer use of .track
     */
    addFeature(feature: import("ol").Feature<import("ol/geom/Geometry").default>): void;
    /**
     * adds an edit to the tracker. prefer use of .track
     */
    editFeature(feature: import("ol").Feature<import("ol/geom/Geometry").default>): void;
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
}

export const featureStoreStateSymbol: symbol;

/**
 * Enumeration of feature store item states
 */
export const enum FeatureStoreLayerState {
    DYNAMIC,
    STATIC,
    EDITED
}

/**
 * Set on an ol.Feature or Cesium.Cesium3DTileFeature to indicate its style before it was hidden or highlighted.
 * Can be undefined or ol.style.Style for ol.Features and Cesium.Color for Cesium.Cesium3DTileFeatures.
 */
export const originalStyle: symbol;

/**
 * Set on an ol.Feature or Cesium.Cesium3DTileFeature to indicate that this features is highlighted.
 * Its value is a {@link VectorStyleItem}.
 */
export const highlighted: symbol;

/**
 * Is a boolean value set on ol.Feature or Cesium.Cesium3DTileFeature to indicate it is hidden
 * by the layers {@link FeatureVisibility}.
 */
export const hidden: symbol;

/**
 * Is a boolean value set on ol.Feature or Cesium.Cesium3DTileFeature to indicate it is hidden
 * by the {@link GlobalHider}
 */
export const globalHidden: symbol;

export interface HighlightedObject {
    style: VectorStyleItem;
    features: Set<import("ol").Feature<import("ol/geom/Geometry").default> | import("@vcmap/cesium").Cesium3DTileFeature | import("@vcmap/cesium").Cesium3DTilePointFeature>;
}

export interface FeatureVisibilityEvent {
    action: FeatureVisibilityAction;
    ids: string[];
}

export function featureExists(feature: import("@vcmap/cesium").Cesium3DTileFeature | import("@vcmap/cesium").Cesium3DTilePointFeature): boolean;

/**
 * Enumeration of feature visibility actions.
 */
export const enum FeatureVisibilityAction {
    HIGHLIGHT,
    UNHIGHLIGHT,
    HIDE,
    SHOW
}

export function synchronizeFeatureVisibility(source: FeatureVisibility, destination: FeatureVisibility): (...params: any[]) => any;

export class FeatureVisibility {
    hiddenObjects: {
        [key: string]: Set<import("@vcmap/cesium").Cesium3DTileFeature | import("ol").Feature<import("ol/geom/Geometry").default> | import("@vcmap/cesium").Entity>;
    };
    highlightedObjects: {
        [key: string]: HighlightedObject;
    };
    lastUpdated: number;
    /**
     * An event raised when the hidden or highlighted ids change. Is called with
     * {@link FeatureVisibilityEvent} as its only argument
     */
    changed: VcsEvent<FeatureVisibilityEvent>;
    /**
     * highlights a number of features by ID (import("@vcmap/cesium").Cesium3DTileFeature|ol/Feature) with the given color.
     */
    highlight(toHighlight: {
        [key: string]: VectorStyleItem | import("@vcmap/cesium").Color | import("ol/style/Style").default;
    }): void;
    /**
     * unhighlights a number of features given by the ID (import("@vcmap/cesium").Cesium3DTileFeature|import("ol").Feature<import("ol/geom/Geometry").default>)
     * @param toUnHighlight - Array with IDS to unhighlight
     */
    unHighlight(toUnHighlight: string[]): void;
    /**
     * clears all highlighted objects
     */
    clearHighlighting(): void;
    hasHighlightFeature(id: string | number, feature: import("ol").Feature<import("ol/geom/Geometry").default> | import("@vcmap/cesium").Cesium3DTileFeature): boolean;
    addHighlightFeature(id: string | number, feature: import("ol").Feature<import("ol/geom/Geometry").default> | import("@vcmap/cesium").Cesium3DTileFeature): void;
    /**
     * hides a number of objects
     * @param toHide - A list of Object Ids which will be hidden
     */
    hideObjects(toHide: (string | number)[]): void;
    /**
     * unHides a number of objects
     * @param unHide - A list of Object Ids which will be unHidden
     */
    showObjects(unHide: (string | number)[]): void;
    /**
     * clears all the hidden objects
     */
    clearHiddenObjects(): void;
    hasHiddenFeature(id: string | number, feature: import("ol").Feature<import("ol/geom/Geometry").default> | import("@vcmap/cesium").Cesium3DTileFeature | import("@vcmap/cesium").Entity): boolean;
    addHiddenFeature(id: string | number, feature: import("ol").Feature<import("ol/geom/Geometry").default> | import("@vcmap/cesium").Cesium3DTileFeature | import("@vcmap/cesium").Entity): void;
    /**
     * Clears all caches and removes cesium events.
     */
    destroy(): void;
}

export function getFormat(responseType: string, options: any): null | import("ol/format/Feature").default;

export interface GeoJSONData {
    features: import("ol").Feature<import("ol/geom/Geometry").default>[];
    style?: StyleItem | undefined;
    vcsMeta?: VcsMeta | undefined;
}

export interface GeoJSONinternalReadOptions extends GeoJSONreadOptions {
    formatOptions?: import("ol/format/Feature").ReadOptions | undefined;
    embeddedIcons?: string[] | undefined;
}

/**
 */
export interface GeoJSONreadOptions {
    /**
     * projection of the output features, if undefined Mercator will be used
    */
    targetProjection?: Projection | undefined;
    /**
     * projection of the input dataset if undefined WGS84 will be assumed
    */
    dataProjection?: Projection | undefined;
    dynamicStyle?: boolean;
    readLegacyStyleOptions?: boolean;
    dontReadStyle?: boolean;
    defaultStyle?: VectorStyleItem | undefined;
}

/**
 */
export interface GeoJSONwriteOptions {
    /**
     * whether to write an object or a string
    */
    asObject?: boolean;
    /**
     * whether to include vcsStyle options
    */
    writeStyle?: boolean;
    /**
     * whether to output the default style. if the style of a layer is the default layer it is not written.
    */
    writeDefaultStyle?: boolean;
    /**
     * whether to embed custom icons when writing styles, otherwise no style is written for custom icons
    */
    embedIcons?: boolean;
    /**
     * pretty print the json, if not asObject
    */
    prettyPrint?: boolean;
    /**
     * whether to output the feature ID
    */
    writeId?: boolean;
}

export function getEPSGCodeFromGeojson(geojson: any): string | null;

/**
 * updates legacy features to the new olcesium namespaceing olcs_
 */
export function updateLegacyFeature(feature: import("ol").Feature<import("ol/geom/Geometry").default>): void;

/**
 * parses a string to GeojsonLayer
 */
export function parseGeoJSON(input: string | any, readOptions?: GeoJSONreadOptions): GeoJSONData;

export function writeGeoJSONFeature(feature: import("ol").Feature<import("ol/geom/Geometry").default>, options?: GeoJSONwriteOptions, embeddedIcons?: any[]): any;

/**
 * Writes all the features of the current layer to GeojsonLayer
 */
export function writeGeoJSON(data: GeoJSONData, options?: GeoJSONwriteOptions): string | any;

/**
 */
export interface GeoJSONOptions extends VectorOptions {
    /**
     * an array of GeojsonLayer features to parse
    */
    features?: object[] | undefined;
}

/**
 * indicates, that this feature is part of the options
 */
export const featureFromOptions: symbol;

/**
 * GeojsonLayer layer for Cesium, OpenlayersMap and ObliqueMap
 */
export class GeoJSONLayer extends VectorLayer {
    constructor(options: GeoJSONOptions);
    static getDefaultOptions(): GeoJSONOptions;
    /**
     * Fetches the data for the layer. If data is already fetched returns a resolved Promise
     */
    fetchData(): Promise<void>;
    source: import("ol/source").Vector<import("ol/geom/Geometry").default>;
    projection: Projection;
    maxResolution: number;
    minResolution: number;
    dontUseTerrainForOblique: boolean;
    highlightStyle: VectorStyleItem;
    /**
     * A flag to indicate, whether the features in the layer have a UUID, allowing certain interactions,
     * e.g. hidding its features in plannings
     */
    hasFeatureUUID: boolean;
    /**
     * If true, the cesium synchronizers are destroyed on map change
     */
    isDynamic: boolean;
    vectorProperties: VectorProperties;
    allowPicking: boolean;
    visibility: boolean;
    /**
     * An event, called when the style of the layer changes. Is passed the new style item as its value.
     */
    styleChanged: VcsEvent<StyleItem>;
    /**
     * a height offset for rendering of a balloon for a feature of this layer.
     */
    balloonHeightOffset: number;
    /**
     * FeatureVisibility tracks the highlighting and hiding of features on this layer
     */
    featureVisibility: FeatureVisibility;
    /**
     * The style the layer had at construction
     */
    readonly defaultStyle: StyleItem;
    /**
     * style, use setStyle to change
     */
    readonly style: StyleItem;
    /**
     * Generic properties to be added to each feature. Use assignGenericFeatureProperties to change them.
     */
    readonly genericFeatureProperties: any;
    /**
     * Metadata on the extent of the data in this layer. Depending on the implementation, data is only requested
     * for this extent (e.g. {@see RasterLayer})
     */
    extent: Extent | null;
    /**
     * Whether this layer should be active on startup or not. Relevant for creating links.
     */
    activeOnStartup: boolean;
    /**
     * the names of the maps this layer is shown, all if empty
     */
    mapNames: string[];
    /**
     * The class names of the supported maps.
     */
    protected _supportedMaps: string[];
    /**
     * Called when the zIndex of this layer is changed. Is passed the new zIndex as its only argument.
     */
    zIndexChanged: VcsEvent<number>;
    /**
     * array of object Ids which should be hidden within the context of the layers layerCollection, if this layer is active
     */
    hiddenObjectIds: string[];
    /**
     * event raised if the exclusives group of the layer changes. is passed the array of exclusive groups as its only argument
     */
    exclusiveGroupsChanged: VcsEvent<(string | symbol)[]>;
    globalHider: GlobalHider;
    copyright: CopyrightOptions | undefined;
    /**
     * Event raised, if the layers state changes. Is passed the LayerState as its only parameter
     */
    stateChanged: VcsEvent<LayerState>;
    /**
     * An optional feature provider to provider features based on click events.
     */
    featureProvider: AbstractFeatureProvider;
    /**
     * True if this layer has been initialized, typically after its first activation.
     */
    readonly initialized: boolean;
    readonly active: boolean;
    readonly loading: boolean;
    readonly state: LayerState;
    /**
     * A layers url, should on be configured, else an empty string
     */
    url: string;
    /**
     * Indicates, that this layer is part of an exclusiveGroup
     */
    readonly exclusive: boolean;
    /**
     * An array of arbitrary exclusive groups
     */
    readonly exclusiveGroups: any;
    zIndex: number;
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
}

export class GlobalHider {
    hiddenObjects: {
        [key: string]: number;
    };
    lastUpdated: number;
    /**
     * An event raised when the hidden ids change. Is called with
     * {@link FeatureVisibilityEvent} as its only argument
     */
    changed: VcsEvent<FeatureVisibilityEvent>;
    /**
     * Add a tick to the hide count, hidding the features if they are not already hidden
     */
    hideObjects(uuids: string[]): void;
    /**
     * Subtract from the hide count for an Array of ids. If the array reaches 0, features with said UUID will be shown
     */
    showObjects(uuids: string[]): void;
    addFeature(uuid: number | string, feature: import("ol").Feature<import("ol/geom/Geometry").default> | import("@vcmap/cesium").Cesium3DTileFeature | import("@vcmap/cesium").Cesium3DTilePointFeature | import("@vcmap/cesium").Entity): void;
    hasFeature(uuid: string | number, feature: import("ol").Feature<import("ol/geom/Geometry").default> | import("@vcmap/cesium").Cesium3DTileFeature | import("@vcmap/cesium").Cesium3DTilePointFeature | import("@vcmap/cesium").Entity): boolean;
}

export function getGlobalHider(): GlobalHider;

export interface GenericFeature {
    longitude: number;
    latitude: number;
    height: number;
    layerName: string;
    layerClass: string;
    attributes: any;
    relativeToGround: boolean;
}

export interface SplitLayer extends Layer {
    splitDirection: import("@vcmap/cesium").SplitDirection;
    splitDirectionChanged: VcsEvent<import("@vcmap/cesium").SplitDirection>;
}

export interface CopyrightOptions {
    provider?: string | undefined;
    url?: string | undefined;
    year?: string | undefined;
}

/**
 */
export interface VcsMeta extends VectorPropertiesOptions {
    /**
     * the version of the vcsMeta schema
    */
    version?: string | undefined;
    style?: VectorStyleItemOptions | DeclarativeStyleItemOptions | undefined;
    embeddedIcons?: string[] | undefined;
    screenSpaceError?: number | undefined;
    flightOptions?: any | undefined;
    baseUrl?: string | undefined;
}

/**
 */
export interface LayerOptions extends VcsObjectOptions {
    /**
     * the name of the layer, used to retrieve the layer from the framework. if not specified, a uuid is generated
    */
    name?: string | undefined;
    /**
     * if true the layer will be activated on initialization
    */
    activeOnStartup?: boolean;
    /**
     * whether to allow picking on this layer
    */
    allowPicking?: boolean;
    /**
     * zIndex of this layer
    */
    zIndex?: number | undefined;
    /**
     * metadata on the data extent of the layer.
    */
    extent?: ExtentOptions | undefined;
    /**
     * -
    */
    exclusiveGroups?: (string | symbol)[] | undefined;
    /**
     * the map names on which this layer is shown, all if empty
    */
    mapNames?: string[] | undefined;
    /**
     * for most layers, a resource url will be needed
    */
    url?: string | any | undefined;
    /**
     * an array of building ids which should be hidden if this layer is active
    */
    hiddenObjectIds?: string[] | undefined;
    copyright?: CopyrightOptions | undefined;
}

/**
 * The options passed to a layer implementation.
 */
export interface LayerImplementationOptions {
    name: string;
    url: string;
}

/**
 * The version of vcsMeta schema being written by this helper
 */
export const vcsMetaVersion: string;

/**
 * Abstract base class for Layers.
 * To create a layer Implementation the function `createImplementationsForMap` has to be implemented.
 * To receive implementation options, implement `geImplementationOptions`
 */
export class Layer extends VcsObject {
    constructor(options: LayerOptions);
    static className: string;
    /**
     * Symbol to declare a layers name on its visualizations, e.g. ol.layer.Layer, Cesium.Cesium3DTileset
     */
    static vcsLayerNameSymbol: symbol;
    static getDefaultOptions(): LayerOptions;
    /**
     * Metadata on the extent of the data in this layer. Depending on the implementation, data is only requested
     * for this extent (e.g. {@see RasterLayer})
     */
    extent: Extent | null;
    /**
     * Whether this layer should be active on startup or not. Relevant for creating links.
     */
    activeOnStartup: boolean;
    /**
     * the names of the maps this layer is shown, all if empty
     */
    mapNames: string[];
    /**
     * The class names of the supported maps.
     */
    protected _supportedMaps: string[];
    /**
     * Called when the zIndex of this layer is changed. Is passed the new zIndex as its only argument.
     */
    zIndexChanged: VcsEvent<number>;
    /**
     * array of object Ids which should be hidden within the context of the layers layerCollection, if this layer is active
     */
    hiddenObjectIds: string[];
    /**
     * event raised if the exclusives group of the layer changes. is passed the array of exclusive groups as its only argument
     */
    exclusiveGroupsChanged: VcsEvent<(string | symbol)[]>;
    globalHider: GlobalHider;
    copyright: CopyrightOptions | undefined;
    /**
     * Event raised, if the layers state changes. Is passed the LayerState as its only parameter
     */
    stateChanged: VcsEvent<LayerState>;
    /**
     * An optional feature provider to provider features based on click events.
     */
    featureProvider: AbstractFeatureProvider;
    /**
     * True if this layer has been initialized, typically after its first activation.
     */
    readonly initialized: boolean;
    readonly active: boolean;
    readonly loading: boolean;
    readonly state: LayerState;
    allowPicking: any;
    url: any;
    /**
     * Indicates, that this layer is part of an exclusiveGroup
     */
    readonly exclusive: boolean;
    exclusiveGroups: any;
    zIndex: any;
    /**
     * creates an array of layer implementations for the given map.
     * @param map - Map
     * @returns return the specific implementation
     */
    createImplementationsForMap(map: VcsMap): LayerImplementation<VcsMap>[];
    /**
     * creates or returns a cached array of layer implementations for the given map.
     * @param map - initialized Map
     * @returns return the specific implementation
     */
    getImplementationsForMap(map: VcsMap): LayerImplementation<VcsMap>[];
    /**
     * Returns all implementation of this layer for all maps
     */
    getImplementations(): LayerImplementation<VcsMap>[];
    getImplementationOptions(): LayerImplementationOptions;
    /**
     * Reloads all the data loaded and forces a redraw
     */
    reload(): Promise<void>;
    /**
     * destroys all current implementations and recreates the ones which have an active map.
     * called for instance when the URL for a layer changes
     */
    forceRedraw(): Promise<void>;
    /**
     * returns the Extent of this layer
     */
    getExtent(): Extent;
    /**
     * returns the Extent of this layer or null, if the layers extent was not defined or cannot be established
     */
    getZoomToExtent(): Extent | null;
    /**
     * initializes the layer, can be used to defer loading
     */
    initialize(): Promise<void>;
    /**
     * is called from the map when the map is activated, and this layer is in the layerCollection of the map.
     * Will create an implementation if it does not exits and will forward the activation call to the implementation.
     */
    mapActivated(map: VcsMap): Promise<void>;
    /**
     * is called from the map when the map is deactivated, and this layer is in the layerCollection of the map.
     * will forward deactivation call to the map specific implementation
     */
    mapDeactivated(map: VcsMap): void;
    /**
     * is called when a layer is removed from the layer collection of a map or said map is destroyed.
     * destroys the associated implementation.
     */
    removedFromMap(map: VcsMap): void;
    /**
     * checks if the currently active map supports this layer
     */
    isSupported(map: VcsMap): boolean;
    /**
     * Activates this layer object, i.e. changes its internal view state
     * and updates the map. The returned promise resolves, once the layer & any _implementations are initialized
     * and all data is loaded.
     * Once the promise resolves, the layer can still be inactive, if deactivate was called while initializing the layer.
     */
    activate(): Promise<void>;
    /**
     * Deactivates a layer, changing the internal view state
     */
    deactivate(): void;
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
}

/**
 * represents an implementation for a Layer for a specific Map
 */
export class LayerImplementation<T extends VcsMap> extends VcsObject {
    constructor(map: T, options: LayerImplementationOptions);
    map: T;
    url: string;
    /**
     * Whether this implementation has been initialized (e.g. activated at least once)
     */
    readonly initialized: boolean;
    active: boolean;
    loading: boolean;
    /**
     * interface to initialize this implementation, is used to setup elements which have to be created only once.
     * Has to set this.initialized = true;
     */
    initialize(): Promise<void>;
    /**
     * activates the implementation, if the map is also active. calls initialize (only use internally)
     * Once the promise resolves, the layer can still be inactive, if deactivate was called while initializing the layer.
     */
    activate(): Promise<void>;
    /**
     * deactivates the implementation (only use internally)
     */
    deactivate(): void;
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
}

/**
 * Enumeration of possible layer states.
 * State machine: inactive <-> loading -> active -> inactive
 */
export const enum LayerState {
    INACTIVE = 1,
    ACTIVE = 2,
    LOADING = 4
}

export class LayerObliqueImpl extends LayerImplementation<ObliqueMap> {
    constructor(map: ObliqueMap, options: LayerImplementationOptions);
    olLayer: import("ol/layer").Layer<import("ol/source/Source").default> | null;
    initialize(): Promise<void>;
    activate(): Promise<void>;
    deactivate(): void;
    /**
     * returns the ol Layer
     */
    getOLLayer(): import("ol/layer").Layer<import("ol/source/Source").default>;
    destroy(): void;
}

/**
 */
export interface TransformationOptions {
    /**
     * whether to use the terrain or not
    */
    dontUseTerrain?: boolean | undefined;
    /**
     * the image to use, instead of the current image
    */
    image?: ObliqueImage | undefined;
    /**
     * the projection of the input/output coordinates, assumes wgs84
    */
    dataProjection?: import("ol/proj/Projection").default | undefined;
}

export function getLongestSide(coordinates: import("ol/coordinate").Coordinate[]): number;

export function getResolutionOptions(olMap: import("ol/Map").default, image: ObliqueImage): any;

export function getZoom(olMap: import("ol/Map").default, image: ObliqueImage, distance: number): number;

/**
 * converts a geometry in mercator format to image coordinates
 */
export function mercatorGeometryToImageGeometry(inputSourceGeometry: import("ol/geom/Geometry").default, destinationGeometry: import("ol/geom/Geometry").default, image: ObliqueImage): Promise<import("ol/geom/Geometry").default>;

/**
 * returns a cloned geometry geometry with coordinates to format to image coordinates
 */
export function imageGeometryToMercatorGeometry(sourceGeometry: import("ol/geom/Geometry").default, destinationGeometry: import("ol/geom/Geometry").default, image: ObliqueImage): Promise<import("ol/geom/Geometry").default>;

export function getPolygonizedGeometry(feature: import("ol").Feature<import("ol/geom/Geometry").default>, retainRectangle?: boolean): import("ol/geom/Geometry").default;

/**
 * sets the geometry from the originalfeature to the oblique feature
 */
export function setNewGeometry(originalFeature: import("ol").Feature<import("ol/geom/Geometry").default>, obliqueFeature: import("ol").Feature<import("ol/geom/Geometry").default>): void;



/**
 * represents a specific vector layer for oblique.
 */
export class VectorObliqueImpl extends LayerObliqueImpl implements FeatureLayerImplementation {
    constructor(map: ObliqueMap, options: VectorImplementationOptions);
    obliqueSource: import("ol/source").Vector<import("ol/geom/Geometry").default>;
    /**
     * The extent of the current image for which features where fetched
     */
    currentExtent: import("ol/extent").Extent | null;
    /**
     * The image name for which the current features where fetched
     */
    fetchedFeaturesForImageName: string | null;
    globalHider: GlobalHider;
    source: import("ol/source").Vector<import("ol/geom/Geometry").default>;
    style: StyleItem;
    featureVisibility: FeatureVisibility;
    olLayer: import("ol/layer").Vector<import("ol/source").Vector<import("ol/geom/Geometry").default>> | null;
    updateStyle(style: StyleItem, silent?: boolean): void;
    protected _addSourceListeners(): void;
    updateObliqueGeometry(originalFeature: import("ol").Feature<import("ol/geom/Geometry").default>, obliqueFeature: import("ol").Feature<import("ol/geom/Geometry").default>): void;

    updateMercatorGeometry(originalFeature: import("ol").Feature<import("ol/geom/Geometry").default>, obliqueFeature: import("ol").Feature<import("ol/geom/Geometry").default>): void;

    /**
     * Synchronizes image Features if the geometry has been changed.
     * also clears source and featureListeners
     */

}

/**
 */
export interface OpenStreetMapOptions extends LayerOptions {
    /**
     * either 'left' or 'right', if omitted none is applied
    */
    splitDirection?: string | undefined;
    /**
     * opacity between 0 and 1
    */
    opacity?: number;
    /**
     * max level to load tiles at
    */
    maxLevel?: number;
}



/**
 * OpenStreetMapLayer Layer
 */
export class OpenStreetMapLayer extends Layer implements SplitLayer {
    constructor(options: OpenStreetMapOptions);
    static getDefaultOptions(): OpenStreetMapOptions;
    /**
     * raised if the split direction changes, is passed the split direction as its only argument
     */
    splitDirectionChanged: VcsEvent<import("@vcmap/cesium").SplitDirection>;
    /**
     * The maximum level to load. Changing requires a redraw to take effect.
     */
    maxLevel: number;
    splitDirection: any;
    opacity: any;
    /**
     * Metadata on the extent of the data in this layer. Depending on the implementation, data is only requested
     * for this extent (e.g. {@see RasterLayer})
     */
    extent: Extent | null;
    /**
     * Whether this layer should be active on startup or not. Relevant for creating links.
     */
    activeOnStartup: boolean;
    /**
     * the names of the maps this layer is shown, all if empty
     */
    mapNames: string[];
    /**
     * The class names of the supported maps.
     */
    protected _supportedMaps: string[];
    /**
     * Called when the zIndex of this layer is changed. Is passed the new zIndex as its only argument.
     */
    zIndexChanged: VcsEvent<number>;
    /**
     * array of object Ids which should be hidden within the context of the layers layerCollection, if this layer is active
     */
    hiddenObjectIds: string[];
    /**
     * event raised if the exclusives group of the layer changes. is passed the array of exclusive groups as its only argument
     */
    exclusiveGroupsChanged: VcsEvent<(string | symbol)[]>;
    globalHider: GlobalHider;
    copyright: CopyrightOptions | undefined;
    /**
     * Event raised, if the layers state changes. Is passed the LayerState as its only parameter
     */
    stateChanged: VcsEvent<LayerState>;
    /**
     * An optional feature provider to provider features based on click events.
     */
    featureProvider: AbstractFeatureProvider;
    /**
     * True if this layer has been initialized, typically after its first activation.
     */
    readonly initialized: boolean;
    readonly active: boolean;
    readonly loading: boolean;
    readonly state: LayerState;
    allowPicking: boolean;
    /**
     * A layers url, should on be configured, else an empty string
     */
    url: string;
    /**
     * Indicates, that this layer is part of an exclusiveGroup
     */
    readonly exclusive: boolean;
    /**
     * An array of arbitrary exclusive groups
     */
    readonly exclusiveGroups: any;
    zIndex: number;
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
}

/**
 * Layer implementation for {@link CesiumMap}.
 */
export class LayerOpenlayersImpl extends LayerImplementation<OpenlayersMap> {
    constructor(map: OpenlayersMap, options: LayerImplementationOptions);
    olLayer: import("ol/layer").Layer<import("ol/source/Source").default> | null;
    initialize(): Promise<void>;
    activate(): Promise<void>;
    deactivate(): void;
    /**
     * returns the ol Layer
     */
    getOLLayer(): import("ol/layer").Layer<import("ol/source/Source").default>;
    destroy(): void;
}

/**
 * represents a specific OpenStreetMapLayer layer for openlayers.
 */
export class OpenStreetMapOpenlayersImpl extends RasterLayerOpenlayersImpl {
}



/**
 * RasterLayer implementation for {@link Openlayers}
 */
export class RasterLayerOpenlayersImpl extends LayerOpenlayersImpl implements RasterLayerImplementation {
    constructor(map: OpenlayersMap, options: RasterLayerImplementationOptions);
    splitDirection: import("@vcmap/cesium").SplitDirection;
    minLevel: number;
    maxLevel: number;
    tilingSchema: string;
    extent: Extent;
    opacity: number;
    updateOpacity(opacity: number): void;
    updateSplitDirection(splitDirection: import("@vcmap/cesium").SplitDirection): void;
    olLayer: import("ol/layer").Layer<import("ol/source/Source").default> | null;
}

/**
 * represents a specific OpenLayers SingleImageLayer Layer class.
 */
export class SingleImageOpenlayersImpl extends RasterLayerOpenlayersImpl {
    constructor(map: OpenlayersMap, options: SingleImageImplementationOptions);
    credit: string;
    splitDirection: import("@vcmap/cesium").SplitDirection;
    minLevel: number;
    maxLevel: number;
    tilingSchema: string;
    extent: Extent;
    opacity: number;
    olLayer: import("ol/layer").Layer<import("ol/source/Source").default> | null;
}



/**
 * layer Implementation to render tile boundaries.
 */
export class TileDebugOpenlayersImpl extends LayerOpenlayersImpl implements VectorTileImplementation {
    updateStyle(styleItem: StyleItem, silent: boolean): void;
    updateTiles(args: string[]): void;
}

/**
 * TmsLayer implementation for {@link Openlayers}.
 */
export class TmsOpenlayersImpl extends RasterLayerOpenlayersImpl {
    constructor(map: OpenlayersMap, options: TMSImplementationOptions);
    format: string;
    tileSize: import("ol/size").Size;
    splitDirection: import("@vcmap/cesium").SplitDirection;
    minLevel: number;
    maxLevel: number;
    tilingSchema: string;
    extent: Extent;
    opacity: number;
    olLayer: import("ol/layer").Layer<import("ol/source/Source").default> | null;
}



/**
 * represents a specific vectorlayer for openlayers.
 */
export class VectorOpenlayersImpl extends LayerOpenlayersImpl implements FeatureLayerImplementation {
    constructor(map: OpenlayersMap, options: VectorImplementationOptions);
    source: import("ol/source").Vector<import("ol/geom/Geometry").default>;
    style: StyleItem;
    maxResolution: number;
    minResolution: number;
    featureVisibility: FeatureVisibility;
    olLayer: import("ol/layer/Vector").default<import("ol/source").Vector<import("ol/geom/Geometry").default>> | null;
    updateStyle(style: StyleItem, silent?: boolean): void;
    setVisibility(visibility: boolean): void;
}



/**
 * represents a specific vectorTileLayer for openlayers.
 */
export class VectorTileOpenlayersImpl extends LayerOpenlayersImpl implements VectorTileImplementation {
    constructor(map: OpenlayersMap, options: VectorTileImplementationOptions);
    tileProvider: TileProvider;
    source: import("ol/source").VectorTile;
    tileSize: import("ol/size").Size;
    minLevel: number | undefined;
    maxLevel: number | undefined;
    extent: Extent | undefined;
    /**
     * rerenders the specified tiles
     * rendering happens async
     */
    updateTiles(tileIds: string[]): void;
    updateStyle(style: StyleItem, silent?: boolean): void;
    setVisibility(visibility: boolean): void;
    olLayer: import("ol/layer").Layer<import("ol/source/Source").default> | null;
}

/**
 * represents a specific Cesium WmsOpenlayersImpl Layer class.
 */
export class WmsOpenlayersImpl extends RasterLayerOpenlayersImpl {
    constructor(map: OpenlayersMap, options: WMSImplementationOptions);
    parameters: {
        [key: string]: any;
    };
    version: string;
    tileSize: import("ol/size").Size;
    splitDirection: import("@vcmap/cesium").SplitDirection;
    minLevel: number;
    maxLevel: number;
    tilingSchema: string;
    extent: Extent;
    opacity: number;
    olLayer: import("ol/layer").Layer<import("ol/source/Source").default> | null;
}

/**
 * WmtsLayer implementation for {@link Openlayers}.
 */
export class WmtsOpenlayersImpl extends RasterLayerOpenlayersImpl {
    constructor(map: OpenlayersMap, options: WMTSImplementationOptions);
    layer: string;
    style: string;
    format: string;
    tileMatrixSetID: string;
    tileSize: import("ol/size").Size;
    numberOfLevelZeroTilesX: number;
    numberOfLevelZeroTilesY: number;
    matrixIds: string[];
    openlayersOptions: any;
    splitDirection: import("@vcmap/cesium").SplitDirection;
    minLevel: number;
    maxLevel: number;
    tilingSchema: string;
    extent: Extent;
    opacity: number;
    olLayer: import("ol/layer").Layer<import("ol/source/Source").default> | null;
}

/**
 */
export interface PointCloudOptions extends CesiumTilesetOptions {
    /**
     * Pointsize of the pointcloud in pixel default is 1
    */
    pointSize?: number | string | undefined;
}

export interface PointCloudImplementationOptions extends CesiumTilesetImplementationOptions {
    pointSize?: string | number | undefined;
}

export const defaultPointCloudStyle: DeclarativeStyleItem;

/**
 * represents a specific PointCloudLayer layer for cesium.
 * <h3>Config Parameter</h3>
 * <ul>
 *  <li>url: string: url to the p3dm dataset
 *  <li>pointSize: number: size of the points to display
 * </ul>
 */
export class PointCloudLayer extends CesiumTilesetLayer {
    constructor(options: PointCloudOptions);
    static getDefaultOptions(): PointCloudOptions;
    /**
     * The default point size to fall back on, if no point size is given. Uses Cesium default of 1 if null.
     */
    defaultPointSize: number | string | null;

    pointSize: any;
    highlightStyle: VectorStyleItem;
    screenSpaceError: number;
    screenSpaceErrorMobile: number;
    maximumMemoryUsage: number;
    tilesetOptions: any;

    /**
     * raised if the split direction changes, is passed the split direction as its only argument
     */
    splitDirectionChanged: VcsEvent<import("@vcmap/cesium").SplitDirection>;
    /**
     * A model matrix to apply to each cesium3DTileset created from this layer.
     * This will overwrite any modelMatrix calculated by the offset property.
     */
    modelMatrix: any;
    /**
     * An offset in x, y, z. x and y are in degrees longitude latitude respectively.
     * If a modelMatrix is defined on this layer, setting an offset will not take effect until you
     * set the modelMatrix to undefined.
     */
    offset: import("ol/coordinate").Coordinate | undefined;
    splitDirection: import("@vcmap/cesium").SplitDirection;
    /**
     * An event, called when the style of the layer changes. Is passed the new style item as its value.
     */
    styleChanged: VcsEvent<StyleItem>;
    /**
     * a height offset for rendering of a balloon for a feature of this layer.
     */
    balloonHeightOffset: number;
    /**
     * FeatureVisibility tracks the highlighting and hiding of features on this layer
     */
    featureVisibility: FeatureVisibility;
    /**
     * The style the layer had at construction
     */
    readonly defaultStyle: StyleItem;
    /**
     * style, use setStyle to change
     */
    readonly style: StyleItem;
    /**
     * Generic properties to be added to each feature. Use assignGenericFeatureProperties to change them.
     */
    readonly genericFeatureProperties: any;
    /**
     * Metadata on the extent of the data in this layer. Depending on the implementation, data is only requested
     * for this extent (e.g. {@see RasterLayer})
     */
    extent: Extent | null;
    /**
     * Whether this layer should be active on startup or not. Relevant for creating links.
     */
    activeOnStartup: boolean;
    /**
     * the names of the maps this layer is shown, all if empty
     */
    mapNames: string[];
    /**
     * The class names of the supported maps.
     */
    protected _supportedMaps: string[];
    /**
     * Called when the zIndex of this layer is changed. Is passed the new zIndex as its only argument.
     */
    zIndexChanged: VcsEvent<number>;
    /**
     * array of object Ids which should be hidden within the context of the layers layerCollection, if this layer is active
     */
    hiddenObjectIds: string[];
    /**
     * event raised if the exclusives group of the layer changes. is passed the array of exclusive groups as its only argument
     */
    exclusiveGroupsChanged: VcsEvent<(string | symbol)[]>;
    globalHider: GlobalHider;
    copyright: CopyrightOptions | undefined;
    /**
     * Event raised, if the layers state changes. Is passed the LayerState as its only parameter
     */
    stateChanged: VcsEvent<LayerState>;
    /**
     * An optional feature provider to provider features based on click events.
     */
    featureProvider: AbstractFeatureProvider;
    /**
     * True if this layer has been initialized, typically after its first activation.
     */
    readonly initialized: boolean;
    readonly active: boolean;
    readonly loading: boolean;
    readonly state: LayerState;
    allowPicking: boolean;
    /**
     * A layers url, should on be configured, else an empty string
     */
    url: string;
    /**
     * Indicates, that this layer is part of an exclusiveGroup
     */
    readonly exclusive: boolean;
    /**
     * An array of arbitrary exclusive groups
     */
    readonly exclusiveGroups: any;
    zIndex: number;
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
}

/**
 */
export interface RasterLayerOptions extends LayerOptions {
    /**
     * minLevel to show (if not specified, calculated from extent)
    */
    minLevel?: number | undefined;
    /**
     * maxLevel to show
    */
    maxLevel?: number;
    /**
     * either "geographic" or "mercator"
    */
    tilingSchema?: string;
    /**
     * opacity between 0 and 1
    */
    opacity?: number;
    /**
     * either 'left' or 'right', none if omitted
    */
    splitDirection?: string | undefined;
}

export interface RasterLayerImplementationOptions extends LayerImplementationOptions {
    minLevel: number;
    maxLevel: number;
    tilingSchema: string;
    opacity: number;
    splitDirection: import("@vcmap/cesium").SplitDirection;
    extent?: Extent | undefined;
}

export interface RasterLayerImplementation extends LayerImplementation<VcsMap> {
    updateOpacity: (...params: any[]) => any;
    updateSplitDirection: (...params: any[]) => any;
}

/**
 * Enumeration of tiling schemes.
 */
export const enum TilingScheme {
    GEOGRAPHIC,
    MERCATOR
}

/**
 * Gets the tiling scheme associated with this layerConfig
 */
export function getTilingScheme(layerOptions: any): import("@vcmap/cesium").WebMercatorTilingScheme | import("@vcmap/cesium").GeographicTilingScheme;

export function calculateMinLevel(extent: Extent, tilingScheme: import("@vcmap/cesium").GeographicTilingScheme | import("@vcmap/cesium").WebMercatorTilingScheme, maxLevel: number, minLevel?: number): number;



/**
 * This abstract class allows for automatic loading scheme determination
 * for raster layers
 */
export class RasterLayer extends Layer implements SplitLayer {
    constructor(options: RasterLayerOptions);
    static getDefaultOptions(): RasterLayerOptions;
    /**
     * The {@link RasterLayer.TilingScheme} of this layer
     */
    tilingSchema: string;
    maxLevel: number;
    minLevel: number;

    /**
     * raised if the split direction changes, is passed the split direction as its only argument
     */
    splitDirectionChanged: VcsEvent<import("@vcmap/cesium").SplitDirection>;
    splitDirection: any;
    opacity: any;
    /**
     * Metadata on the extent of the data in this layer. Depending on the implementation, data is only requested
     * for this extent (e.g. {@see RasterLayer})
     */
    extent: Extent | null;
    /**
     * Whether this layer should be active on startup or not. Relevant for creating links.
     */
    activeOnStartup: boolean;
    /**
     * the names of the maps this layer is shown, all if empty
     */
    mapNames: string[];
    /**
     * The class names of the supported maps.
     */
    protected _supportedMaps: string[];
    /**
     * Called when the zIndex of this layer is changed. Is passed the new zIndex as its only argument.
     */
    zIndexChanged: VcsEvent<number>;
    /**
     * array of object Ids which should be hidden within the context of the layers layerCollection, if this layer is active
     */
    hiddenObjectIds: string[];
    /**
     * event raised if the exclusives group of the layer changes. is passed the array of exclusive groups as its only argument
     */
    exclusiveGroupsChanged: VcsEvent<(string | symbol)[]>;
    globalHider: GlobalHider;
    copyright: CopyrightOptions | undefined;
    /**
     * Event raised, if the layers state changes. Is passed the LayerState as its only parameter
     */
    stateChanged: VcsEvent<LayerState>;
    /**
     * An optional feature provider to provider features based on click events.
     */
    featureProvider: AbstractFeatureProvider;
    /**
     * True if this layer has been initialized, typically after its first activation.
     */
    readonly initialized: boolean;
    readonly active: boolean;
    readonly loading: boolean;
    readonly state: LayerState;
    allowPicking: boolean;
    /**
     * A layers url, should on be configured, else an empty string
     */
    url: string;
    /**
     * Indicates, that this layer is part of an exclusiveGroup
     */
    readonly exclusive: boolean;
    /**
     * An array of arbitrary exclusive groups
     */
    readonly exclusiveGroups: any;
    zIndex: number;
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
}

/**
 */
export interface SingleImageOptions extends RasterLayerOptions {
    /**
     * credit
    */
    credit?: string | undefined;
}

export interface SingleImageImplementationOptions extends RasterLayerImplementationOptions {
    credit?: string | undefined;
}

/**
 * Image layer for Cesium and OpenlayersMap
 */
export class SingleImageLayer extends RasterLayer {
    constructor(options: SingleImageOptions);
    static getDefaultOptions(): SingleImageOptions;
    credit: string;
    /**
     * sets the image extent
     */
    setExtent(extent: Extent): void;
    /**
     * The {@link RasterLayer.TilingScheme} of this layer
     */
    tilingSchema: string;
    maxLevel: number;
    minLevel: number;

    /**
     * raised if the split direction changes, is passed the split direction as its only argument
     */
    splitDirectionChanged: VcsEvent<import("@vcmap/cesium").SplitDirection>;
    /**
     * The split directions of this layer
     */
    splitDirection: import("@vcmap/cesium").SplitDirection;
    /**
     * The opacity between 0 (fully transparent) and 1 (fully opaque)
     */
    opacity: number;
    /**
     * Metadata on the extent of the data in this layer. Depending on the implementation, data is only requested
     * for this extent (e.g. {@see RasterLayer})
     */
    extent: Extent | null;
    /**
     * Whether this layer should be active on startup or not. Relevant for creating links.
     */
    activeOnStartup: boolean;
    /**
     * the names of the maps this layer is shown, all if empty
     */
    mapNames: string[];
    /**
     * The class names of the supported maps.
     */
    protected _supportedMaps: string[];
    /**
     * Called when the zIndex of this layer is changed. Is passed the new zIndex as its only argument.
     */
    zIndexChanged: VcsEvent<number>;
    /**
     * array of object Ids which should be hidden within the context of the layers layerCollection, if this layer is active
     */
    hiddenObjectIds: string[];
    /**
     * event raised if the exclusives group of the layer changes. is passed the array of exclusive groups as its only argument
     */
    exclusiveGroupsChanged: VcsEvent<(string | symbol)[]>;
    globalHider: GlobalHider;
    copyright: CopyrightOptions | undefined;
    /**
     * Event raised, if the layers state changes. Is passed the LayerState as its only parameter
     */
    stateChanged: VcsEvent<LayerState>;
    /**
     * An optional feature provider to provider features based on click events.
     */
    featureProvider: AbstractFeatureProvider;
    /**
     * True if this layer has been initialized, typically after its first activation.
     */
    readonly initialized: boolean;
    readonly active: boolean;
    readonly loading: boolean;
    readonly state: LayerState;
    allowPicking: boolean;
    /**
     * A layers url, should on be configured, else an empty string
     */
    url: string;
    /**
     * Indicates, that this layer is part of an exclusiveGroup
     */
    readonly exclusive: boolean;
    /**
     * An array of arbitrary exclusive groups
     */
    readonly exclusiveGroups: any;
    zIndex: number;
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
}

export interface TerrainProviderOptions {
    url: string;
    requestVertexNormals?: boolean | undefined;
    requestWaterMask?: boolean | undefined;
}

export function getTerrainProviderForUrl(options: TerrainProviderOptions): import("@vcmap/cesium").CesiumTerrainProvider;

/**
 * changes input coordinate Array in place, new height can also be accessed by coordinates[x][2]
 * @param [optSourceProjection] - if input is not WGS84
 */
export function getHeightFromTerrainProvider(terrainProvider: import("@vcmap/cesium").CesiumTerrainProvider, coordinates: import("ol/coordinate").Coordinate[], optSourceProjection?: Projection, result?: import("ol/coordinate").Coordinate[]): Promise<import("ol/coordinate").Coordinate[]>;

/**
 * checks, whether a terrain tile is available at given position or not
 */
export function isTerrainTileAvailable(terrainProvider: import("@vcmap/cesium").CesiumTerrainProvider, level: number, position: import("@vcmap/cesium").Cartographic): boolean;

/**
 */
export interface TerrainOptions extends LayerOptions {
    /**
     * if the terrain should be shaded
    */
    requestVertexNormals?: boolean;
    /**
     * if a watermask should be requested
    */
    requestWaterMask?: boolean;
}

export interface TerrainImplementationOptions extends LayerImplementationOptions {
    requestVertexNormals: boolean;
    requestWaterMask: boolean;
}

/**
 * represents a terrain layer.
 */
export class TerrainLayer extends Layer {
    constructor(options: TerrainOptions);
    static getDefaultOptions(): TerrainOptions;
    requestVertexNormals: boolean;
    requestWaterMask: boolean;
    /**
     * getHeight for coordinates
     * @param coords - the height is added to the coordinates in place
     */
    getHeightForWGS84Coordinates(coords: import("ol/coordinate").Coordinate[]): Promise<import("ol/coordinate").Coordinate[]>;
    /**
     * Metadata on the extent of the data in this layer. Depending on the implementation, data is only requested
     * for this extent (e.g. {@see RasterLayer})
     */
    extent: Extent | null;
    /**
     * Whether this layer should be active on startup or not. Relevant for creating links.
     */
    activeOnStartup: boolean;
    /**
     * the names of the maps this layer is shown, all if empty
     */
    mapNames: string[];
    /**
     * The class names of the supported maps.
     */
    protected _supportedMaps: string[];
    /**
     * Called when the zIndex of this layer is changed. Is passed the new zIndex as its only argument.
     */
    zIndexChanged: VcsEvent<number>;
    /**
     * array of object Ids which should be hidden within the context of the layers layerCollection, if this layer is active
     */
    hiddenObjectIds: string[];
    /**
     * event raised if the exclusives group of the layer changes. is passed the array of exclusive groups as its only argument
     */
    exclusiveGroupsChanged: VcsEvent<(string | symbol)[]>;
    globalHider: GlobalHider;
    copyright: CopyrightOptions | undefined;
    /**
     * Event raised, if the layers state changes. Is passed the LayerState as its only parameter
     */
    stateChanged: VcsEvent<LayerState>;
    /**
     * An optional feature provider to provider features based on click events.
     */
    featureProvider: AbstractFeatureProvider;
    /**
     * True if this layer has been initialized, typically after its first activation.
     */
    readonly initialized: boolean;
    readonly active: boolean;
    readonly loading: boolean;
    readonly state: LayerState;
    allowPicking: boolean;
    /**
     * A layers url, should on be configured, else an empty string
     */
    url: string;
    /**
     * Indicates, that this layer is part of an exclusiveGroup
     */
    readonly exclusive: boolean;
    /**
     * An array of arbitrary exclusive groups
     */
    readonly exclusiveGroups: any;
    zIndex: number;
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
}

export function tiledLayerLoaded(layer: CesiumTilesetLayer | FeatureStoreLayer, timeout?: number): Promise<void>;

export function globeLoaded(globe: import("@vcmap/cesium").Globe, timeout?: number): Promise<void>;

/**
 */
export interface MVTTileProviderOptions extends TileProviderOptions {
    /**
     * to pbf tiled datasource {x}, {y}, {z} are placeholders for x, y, zoom
    */
    url: string;
    /**
     * if property exists will be used to set the ID of the feature
    */
    idProperty?: string | undefined;
}

/**
 * Loads the pbf tiles
 */
export class MVTTileProvider extends TileProvider {
    constructor(options: MVTTileProviderOptions);
    static readonly className: any;
    static getDefaultOptions(): MVTTileProviderOptions;
    url: string;
    idProperty: string | undefined;
    /**
     * Cesium Webmercator TilingScheme
     */
    readonly tilingScheme: import("@vcmap/cesium").WebMercatorTilingScheme;
    /**
     * sorted baseLevels, maximumLevel first example: [18,17,16]
     */
    readonly baseLevels: number[];
    /**
     * cache of tiles for each baseLevel
     */
    cache: Map<number, import("ol/structs/LRUCache").default<Promise<import("rbush").default<tileProviderRTreeEntry>>>>;
    /**
     * Caches the loaded rTrees for quick Access to all features.
     */
    rtreeCache: Map<string, import("rbush").default<tileProviderRTreeEntry>>;
    readonly trackFeaturesToTiles: boolean;
    allowTileAggregation: boolean;
    /**
     * set of currently loaded featureIds with the corresponding tileIds
     */
    readonly featureIdToTileIds: Map<string, Set<string>>;
    /**
     * is raised for each loaded Tile; has the tileId and a rtree as parameters
     */
    tileLoadedEvent: VcsEvent<TileLoadedEvent>;
    /**
     * use setTileCacheSize to change
     */
    readonly tileCacheSize: number;
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
}

/**
 */
export interface StaticGeoJSONTileProviderOptions extends TileProviderOptions {
    /**
     * url to the geojson
    */
    url: string;
}

/**
 * Loads the provided geojson url and tiles the content in memory, data is only requested once
 */
export class StaticGeoJSONTileProvider extends TileProvider {
    constructor(options: StaticGeoJSONTileProviderOptions);
    static readonly className: any;
    static getDefaultOptions(): StaticGeoJSONTileProviderOptions;
    url: string;
    /**
     * Cesium Webmercator TilingScheme
     */
    readonly tilingScheme: import("@vcmap/cesium").WebMercatorTilingScheme;
    /**
     * sorted baseLevels, maximumLevel first example: [18,17,16]
     */
    readonly baseLevels: number[];
    /**
     * cache of tiles for each baseLevel
     */
    cache: Map<number, import("ol/structs/LRUCache").default<Promise<import("rbush").default<tileProviderRTreeEntry>>>>;
    /**
     * Caches the loaded rTrees for quick Access to all features.
     */
    rtreeCache: Map<string, import("rbush").default<tileProviderRTreeEntry>>;
    readonly trackFeaturesToTiles: boolean;
    allowTileAggregation: boolean;
    /**
     * set of currently loaded featureIds with the corresponding tileIds
     */
    readonly featureIdToTileIds: Map<string, Set<string>>;
    /**
     * is raised for each loaded Tile; has the tileId and a rtree as parameters
     */
    tileLoadedEvent: VcsEvent<TileLoadedEvent>;
    /**
     * use setTileCacheSize to change
     */
    readonly tileCacheSize: number;
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
}

export interface tileProviderRTreeEntry {
    minX: number;
    minY: number;
    maxX: number;
    maxY: number;
    value: import("ol").Feature<import("ol/geom/Geometry").default>;
}

/**
 * resolutions to levels
 */
export const mercatorResolutionsToLevel: number[];

/**
 * transforms cesium geographic rectangle to mercator extent
 * @param rectangle - in wgs84 radians
 * @returns extent in mercator
 */
export function rectangleToExtent(rectangle: import("@vcmap/cesium").Rectangle): import("ol/extent").Extent;

/**
 */
export interface TileProviderOptions extends VcsObjectOptions {
    /**
     * size of the LRU (least recently used) tileCache per baseLevel
    */
    tileCacheSize?: number;
    /**
     * baseLevels (these levels will be requested by the loader, all other child levels will be interpolated
    */
    baseLevels?: number[];
    /**
     * tracks in which tile each feature exists. (features without an ID will be ignored). Better performance if deactivated, but does not allow for featureVisibility. Should be set to false if not unique featureID is provided.
    */
    trackFeaturesToTiles?: boolean;
    /**
     * allows aggregation of tiles if requested minLevel is lower than provided baseLevels ( if true, allows for aggregating up to two levels (16 child tiles) into a tile)
    */
    allowTileAggregation?: boolean;
}

/**
 */
export interface TileLoadedEvent {
    /**
     * id of the tile
    */
    tileId: string;
    /**
     * rbush rTree with the features, use rtree.all().map(item => item.value);
    */
    rtree: import("rbush").default<tileProviderRTreeEntry>;
}

/**
 * TileProvider class
 */
export class TileProvider extends VcsObject {
    constructor(options: TileProviderOptions);
    static readonly className: any;
    static getDefaultOptions(): TileProviderOptions;
    /**
     * Cesium Webmercator TilingScheme
     */
    readonly tilingScheme: import("@vcmap/cesium").WebMercatorTilingScheme;
    /**
     * sorted baseLevels, maximumLevel first example: [18,17,16]
     */
    readonly baseLevels: number[];
    /**
     * cache of tiles for each baseLevel
     */
    cache: Map<number, import("ol/structs/LRUCache").default<Promise<import("rbush").default<tileProviderRTreeEntry>>>>;
    /**
     * Caches the loaded rTrees for quick Access to all features.
     */
    rtreeCache: Map<string, import("rbush").default<tileProviderRTreeEntry>>;
    readonly trackFeaturesToTiles: boolean;
    allowTileAggregation: boolean;
    /**
     * set of currently loaded featureIds with the corresponding tileIds
     */
    readonly featureIdToTileIds: Map<string, Set<string>>;
    /**
     * is raised for each loaded Tile; has the tileId and a rtree as parameters
     */
    tileLoadedEvent: VcsEvent<TileLoadedEvent>;
    /**
     * use setTileCacheSize to change
     */
    readonly tileCacheSize: number;
    setTileCacheSize(value: number): Promise<any>;
    /**
     * returns the closest baseLevel for the given resolution
     * @param latitude - in radians
     */
    getBaseLevelForResolution(resolution: number, latitude: number): number;
    /**
     * returns the nearest parent BaseLevel or undefined if no parent baseLevel is found
     */
    getBaseLevel(level: number): number | undefined;
    getCacheKey(x: number, y: number, level: number): string;
    /**
     * returns the features intersecting this coordinate. Depending on the resolution a buffer around the coordinate is requested.
     * The Buffer has the size of the resolution.
     * @param coordinate - in mercator
     * @param resolution - in m per pixel
     */
    getFeaturesByCoordinate(coordinate: import("ol/coordinate").Coordinate, resolution: number): Promise<import("ol").Feature<import("ol/geom/Geometry").default>[]>;
    /**
     * returns features for the requested Tile.
     * @param level - if the level is not a base level, will use the closest match
     */
    getFeaturesForTile(x: number, y: number, level: number): Promise<import("ol").Feature<import("ol/geom/Geometry").default>[]>;
    /**
     * Retrieves all features which intersect the given extent. Will load all intersecting tiles.
     * @param [level] - Optional level to request. Will use highest level if omitted. If the provided level is not a base level, will use the closest match.
     */
    getFeaturesForExtent(extent: Extent, level?: number): Promise<import("ol").Feature<import("ol/geom/Geometry").default>[]>;
    /**
     * calls the given Function for Each feature currently in the cache
     */
    forEachFeature(callback: (...params: any[]) => any): void;
    /**
     * Public API to load features from a source (for example a rest API, or WfsLayer)
     *
     * Can be used to write custom TileProvider to provide an interface to a "feature Source"
     * Can also be used to manipulate the features, for example setting an ID Prefix or filter the features.
     * @example
     * to request Geojson from a rest API:
     * const rectangle = this.tilingScheme.tileXYToRectangle(x, y, z);
     * const southwest = Rectangle.southwest(rectangle);
     * const northeast = Rectangle.northeast(rectangle);
     * const minx = CesiumMath.toDegrees(southwest.longitude);
     * const miny = CesiumMath.toDegrees(southwest.latitude);
     * const maxx = CesiumMath.toDegrees(northeast.longitude);
     * const maxy = CesiumMath.toDegrees(northeast.latitude);
     * const url = `http://myFeatureSource/layer/getFeatures?minx=${minx}&miny=${miny}&maxx=${maxx}&maxy=${maxy}`
     *
     * return fetch.get(url)
     *  .then(response => response.json())
     *  .then((data) => {
     *     const { features } = GeoJSONparseGeoJSON(data.data, { dynamicStyle: true });
     *     return features;
     *   });
     */
    loader(x: number, y: number, z: number): Promise<import("ol").Feature<import("ol/geom/Geometry").default>[]>;
    /**
     * clears the cache and removes all entries
     */
    clearCache(): void;
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
}

/**
 */
export interface URLTemplateTileProviderOptions extends TileProviderOptions {
    /**
     * url Template in the form `http://myFeatureSource/layer/getFeatures?minx={minx}&miny={miny}&maxx={maxx}&maxy={maxy}` or `http://myFeatureSource/layer/getFeatures?x={x}&y={y}&level={z}`
    */
    url: string;
}

/**
 * replaces {x}, {y}, {z} with the x, y, z tiling coordinates
 * replaces {minx}, {miny}, {maxx}, {maxy} with extent of the tile if tilingExtent is provided
 * replaces {locale} with the current locale
 */
export function getURL(url: string, x: number, y: number, z: number, tilingExtent?: import("@vcmap/cesium").Rectangle): string;

/**
 * TileProvider loads GeojsonLayer from the provided URL. The URL has placeholders:
 * the extent in latitude/longitude via: {minx}, {miny}, {maxx}, {maxy}
 * tile Coordinates in x, y, z(level) via:  {x}, {y}, {z}
 * {locale} can be used to request locale aware content.
 */
export class URLTemplateTileProvider extends TileProvider {
    constructor(options: URLTemplateTileProviderOptions);
    static readonly className: any;
    static getDefaultOptions(): URLTemplateTileProviderOptions;
    url: string;
    /**
     * Cesium Webmercator TilingScheme
     */
    readonly tilingScheme: import("@vcmap/cesium").WebMercatorTilingScheme;
    /**
     * sorted baseLevels, maximumLevel first example: [18,17,16]
     */
    readonly baseLevels: number[];
    /**
     * cache of tiles for each baseLevel
     */
    cache: Map<number, import("ol/structs/LRUCache").default<Promise<import("rbush").default<tileProviderRTreeEntry>>>>;
    /**
     * Caches the loaded rTrees for quick Access to all features.
     */
    rtreeCache: Map<string, import("rbush").default<tileProviderRTreeEntry>>;
    readonly trackFeaturesToTiles: boolean;
    allowTileAggregation: boolean;
    /**
     * set of currently loaded featureIds with the corresponding tileIds
     */
    readonly featureIdToTileIds: Map<string, Set<string>>;
    /**
     * is raised for each loaded Tile; has the tileId and a rtree as parameters
     */
    tileLoadedEvent: VcsEvent<TileLoadedEvent>;
    /**
     * use setTileCacheSize to change
     */
    readonly tileCacheSize: number;
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
}

export interface TMSOptions extends RasterLayerOptions {
    format?: string;
    tileSize?: import("ol/size").Size;
}

export interface TMSImplementationOptions extends RasterLayerImplementationOptions {
    format: string;
    tileSize: import("ol/size").Size;
}

/**
 * TmsLayer Layer
 */
export class TMSLayer extends RasterLayer {
    constructor(options: TMSOptions);
    static getDefaultOptions(): TMSOptions;
    format: string;
    tileSize: import("ol/size").Size;
    /**
     * The {@link RasterLayer.TilingScheme} of this layer
     */
    tilingSchema: string;
    maxLevel: number;
    minLevel: number;

    /**
     * raised if the split direction changes, is passed the split direction as its only argument
     */
    splitDirectionChanged: VcsEvent<import("@vcmap/cesium").SplitDirection>;
    /**
     * The split directions of this layer
     */
    splitDirection: import("@vcmap/cesium").SplitDirection;
    /**
     * The opacity between 0 (fully transparent) and 1 (fully opaque)
     */
    opacity: number;
    /**
     * Metadata on the extent of the data in this layer. Depending on the implementation, data is only requested
     * for this extent (e.g. {@see RasterLayer})
     */
    extent: Extent | null;
    /**
     * Whether this layer should be active on startup or not. Relevant for creating links.
     */
    activeOnStartup: boolean;
    /**
     * the names of the maps this layer is shown, all if empty
     */
    mapNames: string[];
    /**
     * The class names of the supported maps.
     */
    protected _supportedMaps: string[];
    /**
     * Called when the zIndex of this layer is changed. Is passed the new zIndex as its only argument.
     */
    zIndexChanged: VcsEvent<number>;
    /**
     * array of object Ids which should be hidden within the context of the layers layerCollection, if this layer is active
     */
    hiddenObjectIds: string[];
    /**
     * event raised if the exclusives group of the layer changes. is passed the array of exclusive groups as its only argument
     */
    exclusiveGroupsChanged: VcsEvent<(string | symbol)[]>;
    globalHider: GlobalHider;
    copyright: CopyrightOptions | undefined;
    /**
     * Event raised, if the layers state changes. Is passed the LayerState as its only parameter
     */
    stateChanged: VcsEvent<LayerState>;
    /**
     * An optional feature provider to provider features based on click events.
     */
    featureProvider: AbstractFeatureProvider;
    /**
     * True if this layer has been initialized, typically after its first activation.
     */
    readonly initialized: boolean;
    readonly active: boolean;
    readonly loading: boolean;
    readonly state: LayerState;
    allowPicking: boolean;
    /**
     * A layers url, should on be configured, else an empty string
     */
    url: string;
    /**
     * Indicates, that this layer is part of an exclusiveGroup
     */
    readonly exclusive: boolean;
    /**
     * An array of arbitrary exclusive groups
     */
    readonly exclusiveGroups: any;
    zIndex: number;
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
}

/**
 * Added to ol.source.Vector to determine, when the source has last had an update to its features visibility.
 */
export const fvLastUpdated: symbol;

/**
 * Added to ol.source.Vector to determine, when the source has last had an update to its features global visibility.
 */
export const globalHiderLastUpdated: symbol;

export function updateFeatureVisibility(featureVisibility: FeatureVisibility, source: import("ol/source").Vector<import("ol/geom/Geometry").default>): void;

export function updateGlobalHider(globalHider: GlobalHider, source: import("ol/source").Vector<import("ol/geom/Geometry").default>): void;

export function synchronizeFeatureVisibilityWithSource(featureVisibility: FeatureVisibility, source: import("ol/source").Vector<import("ol/geom/Geometry").default>, globalHider: GlobalHider): ((...params: any[]) => void)[];

export function getGenericFeatureFromClickedObject(object: VectorClickedObject, layer: VectorLayer | VectorTileLayer): GenericFeature;

/**
 */
export interface VectorOptions extends FeatureLayerOptions {
    /**
     * if not specified, the framework projection is taken
    */
    projection?: ProjectionOptions | undefined;
    maxResolution?: number | undefined;
    minResolution?: number | undefined;
    dontUseTerrainForOblique?: boolean;
    zIndex?: number;
    highlightStyle?: VectorStyleItemOptions | VectorStyleItem | undefined;
    /**
     * if true, the cesium synchronizers are destroyed on map change
    */
    isDynamic?: boolean;
    vectorProperties?: VectorPropertiesOptions | undefined;
}

export interface VectorGeometryFactoryType {
    getCoordinates: (...params: any[]) => any;
    getGeometryOptions: (...params: any[]) => any;
    createSolidGeometries: (...params: any[]) => any;
    createOutlineGeometries: (...params: any[]) => any;
    createFillGeometries: (...params: any[]) => any;
    createGroundLineGeometries: (...params: any[]) => any;
    createLineGeometries: (...params: any[]) => any;
}

/**
 */
export interface VectorHeightInfo {
    /**
     * if the object is extruded
    */
    extruded: boolean;
    /**
     * storey heights above ground, list has the same length as storeysAboveGround
    */
    storeyHeightsAboveGround: number[];
    /**
     * storey heights below ground, list has the same length as storeysBelowGround
    */
    storeyHeightsBelowGround: number[];
    /**
     * the level above or below mean sea level (minZ value or ground_level or 0)
    */
    groundLevel: number;
    /**
     * a negative height to <i>push</i> the geometry visually into the ground
    */
    skirt: number;
    perPositionHeight: boolean;
    /**
     * heightReference of the feature.
    */
    heightReference: import("@vcmap/cesium").HeightReference;
    heightAboveGroundAdjustment: number;
}

export interface VectorImplementationOptions extends FeatureLayerImplementationOptions {
    source: import("ol/source").Vector<import("ol/geom/Geometry").default>;
    maxResolution: number;
    minResolution: number;
    vectorProperties: VectorProperties;
}

export interface VectorClickedObject extends olFeature<Geometry> {
    clickedPosition: ClickPosition;
}

/**
 * VectorLayer Layer for OpenlayersMap, Cesium and ObliqueMap
 */
export class VectorLayer extends FeatureLayer {
    constructor(options: VectorOptions);
    static readonly className: any;
    static readonly alreadyTransformedToMercator: any;
    static readonly alreadyTransformedToImage: any;
    static readonly obliqueGeometry: any;
    static readonly doNotTransform: any;
    static readonly originalFeatureSymbol: any;
    static getDefaultOptions(): VectorOptions;
    source: import("ol/source").Vector<import("ol/geom/Geometry").default>;
    projection: Projection;
    maxResolution: number;
    minResolution: number;
    dontUseTerrainForOblique: boolean;
    highlightStyle: VectorStyleItem;
    /**
     * A flag to indicate, whether the features in the layer have a UUID, allowing certain interactions,
     * e.g. hidding its features in plannings
     */
    hasFeatureUUID: boolean;
    /**
     * If true, the cesium synchronizers are destroyed on map change
     */
    isDynamic: boolean;
    vectorProperties: VectorProperties;
    allowPicking: any;
    visibility: any;
    /**
     * Returns the layers vcsMeta object
     */
    getVcsMeta(options?: GeoJSONwriteOptions): VcsMeta;
    /**
     * Sets the meta values based on a {@link VcsMeta} Object. Does not carry over the style
     */
    setVcsMeta(vcsMeta: VcsMeta): void;
    /**
     * Changes features which use the layers style or if the layers style is a declarative style so they are re-rendered
     */
    protected _trackStyleChanges(): void;
    /**
     * sets the highlightstyle of this layer
     */
    setHighlightStyle(style: import("ol/style/Style").default | import("ol/style/Style").StyleFunction | VectorStyleItem): void;
    /**
     * returns the openlayers vector source
     */
    getSource(): import("ol/source").Vector<import("ol/geom/Geometry").default>;
    /**
     * add features to the vector layer and return an array with their ids.
     * The geometry will be mutated and transformed to EPSG 3857 mercator coordinate system
     */
    addFeatures(features: import("ol").Feature<import("ol/geom/Geometry").default>[]): (string | number)[];
    /**
     * removes features from the vector layer
     */
    removeFeaturesById(ids: (string | number)[]): void;
    /**
     * removes all features from the vector layer
     */
    removeAllFeatures(): void;
    /**
     * returns an array with features
     * feature geometries are always in EPSG 3857 mercator coordinate system
     */
    getFeaturesById(ids: (string | number)[]): import("ol").Feature<import("ol/geom/Geometry").default>[];
    /**
     * returns an feature if found, otherwise null
     * feature geometries are always in EPSG 3857 mercator coordinate system
     */
    getFeatureById(id: string | number): import("ol").Feature<import("ol/geom/Geometry").default>;
    /**
     * returns an array with features
     * Feature geometries are always in EPSG 3857 mercator coordinate system
     */
    getFeatures(): import("ol").Feature<import("ol/geom/Geometry").default>[];
    /**
     * An event, called when the style of the layer changes. Is passed the new style item as its value.
     */
    styleChanged: VcsEvent<StyleItem>;
    /**
     * a height offset for rendering of a balloon for a feature of this layer.
     */
    balloonHeightOffset: number;
    /**
     * FeatureVisibility tracks the highlighting and hiding of features on this layer
     */
    featureVisibility: FeatureVisibility;
    /**
     * The style the layer had at construction
     */
    readonly defaultStyle: StyleItem;
    /**
     * style, use setStyle to change
     */
    readonly style: StyleItem;
    /**
     * Generic properties to be added to each feature. Use assignGenericFeatureProperties to change them.
     */
    readonly genericFeatureProperties: any;
    /**
     * Metadata on the extent of the data in this layer. Depending on the implementation, data is only requested
     * for this extent (e.g. {@see RasterLayer})
     */
    extent: Extent | null;
    /**
     * Whether this layer should be active on startup or not. Relevant for creating links.
     */
    activeOnStartup: boolean;
    /**
     * the names of the maps this layer is shown, all if empty
     */
    mapNames: string[];
    /**
     * The class names of the supported maps.
     */
    protected _supportedMaps: string[];
    /**
     * Called when the zIndex of this layer is changed. Is passed the new zIndex as its only argument.
     */
    zIndexChanged: VcsEvent<number>;
    /**
     * array of object Ids which should be hidden within the context of the layers layerCollection, if this layer is active
     */
    hiddenObjectIds: string[];
    /**
     * event raised if the exclusives group of the layer changes. is passed the array of exclusive groups as its only argument
     */
    exclusiveGroupsChanged: VcsEvent<(string | symbol)[]>;
    globalHider: GlobalHider;
    copyright: CopyrightOptions | undefined;
    /**
     * Event raised, if the layers state changes. Is passed the LayerState as its only parameter
     */
    stateChanged: VcsEvent<LayerState>;
    /**
     * An optional feature provider to provider features based on click events.
     */
    featureProvider: AbstractFeatureProvider;
    /**
     * True if this layer has been initialized, typically after its first activation.
     */
    readonly initialized: boolean;
    readonly active: boolean;
    readonly loading: boolean;
    readonly state: LayerState;
    /**
     * A layers url, should on be configured, else an empty string
     */
    url: string;
    /**
     * Indicates, that this layer is part of an exclusiveGroup
     */
    readonly exclusive: boolean;
    /**
     * An array of arbitrary exclusive groups
     */
    readonly exclusiveGroups: any;
    zIndex: number;
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
}

/**
 */
export interface VectorPropertiesOptions {
    /**
     * (3D) Either "relativeToGround", "clampToGround" or 'absolute'
    */
    altitudeMode?: string | undefined;
    /**
     * if the features are pickable
    */
    allowPicking?: boolean | undefined;
    /**
     * (3D) the cesium classification type for this layer. one of 'both', 'terrain' or 'cesium3DTile'
    */
    classificationType?: string | undefined;
    /**
     * (3D) Array with 4 numbers by which features are being scaled based on distance see <a href="https://cesium.com/docs/cesiumjs-ref-doc/Billboard.html#scaleByDistance"> here </a>
    */
    scaleByDistance?: number[] | undefined;
    /**
     * (3D) Array with 3 numbers see for explanation: <a href="https://cesium.com/docs/cesiumjs-ref-doc/Billboard.html#eyeOffset"> here </a>
    */
    eyeOffset?: number[] | undefined;
    /**
     * (3D) can be used with altitudeMode relativeToGround
    */
    heightAboveGround?: number | undefined;
    /**
     * (3D) default skirt value to use for extruded features
    */
    skirt?: number | undefined;
    /**
     * (3D) ground height level of the objects
    */
    groundLevel?: number | undefined;
    /**
     * (3D) - default layer extruded Height
    */
    extrudedHeight?: number | undefined;
    /**
     * (3D)
    */
    storeysAboveGround?: number | undefined;
    /**
     * (3D)
    */
    storeysBelowGround?: number | undefined;
    /**
     * (3D)
    */
    storeyHeightsAboveGround?: number[] | number | undefined;
    /**
     * (3D)
    */
    storeyHeightsBelowGround?: number[] | number | undefined;
    /**
     * vcs:undocumented   @deprecated 3.8 default storey height to use for extruded features to draw storey lines
    */
    storeyHeight?: number | undefined;
    modelUrl?: string | undefined;
    modelScaleX?: number;
    modelScaleY?: number;
    modelScaleZ?: number;
    /**
     * in degrees
    */
    modelHeading?: number;
    /**
     * in degrees
    */
    modelPitch?: number;
    /**
     * in degrees
    */
    modelRoll?: number;
    /**
     * Model options are merged with the model definition from model url, scale and orientation and accepts any option passed to a Cesium.Model.
    */
    modelOptions?: any | undefined;
    /**
     * a base URL to resolve relative model URLs against.
    */
    baseUrl?: string | undefined;
}

export interface VectorPropertiesModelOptions {
    url: string;
    scale: number[];
    heading: number;
    pitch: number;
    roll: number;
}

export const enum AltitudeModeCesium {
}

export const enum ClassificationTypeCesium {
}

export function parseNearFarScalar(value: number[], defaultValue: import("@vcmap/cesium").NearFarScalar | undefined): import("@vcmap/cesium").NearFarScalar | undefined;

export function parseCartesian3(value: number[], defaultValue: import("@vcmap/cesium").Cartesian3 | undefined): import("@vcmap/cesium").Cartesian3 | undefined;

/**
 * returns a storeyHeight array
 */
export function parseStoreyHeights(storeyHeights: number[] | number, defaultStoreyHeights: number[] | number): number[];

export function getAltitudeModeOptions(altitudeMode: import("@vcmap/cesium").HeightReference): string;

export function getClassificationTypeOptions(classificationType: import("@vcmap/cesium").ClassificationType): string;

export function getNearFarValueOptions(nearFarScalar: import("@vcmap/cesium").NearFarScalar): number[] | undefined;

export function getCartesian3Options(cartesian3: import("@vcmap/cesium").Cartesian3): number[] | undefined;

/**
 * Properties Collection for VectorLayer Features
 */
export class VectorProperties {
    constructor(options: VectorPropertiesOptions);
    /**
     * Returns the default options for VectorProperties
     */
    static getDefaultOptions(): VectorPropertiesOptions;
    /**
     * Event raised when properties change. is passed an array of keys for the changed properties.
     */
    readonly propertyChanged: VcsEvent<string[]>;
    altitudeMode: any;
    getAltitudeMode(feature: import("ol").Feature<import("ol/geom/Geometry").default>): import("@vcmap/cesium").HeightReference;
    allowPicking: any;
    getAllowPicking(feature: import("ol").Feature<import("ol/geom/Geometry").default>): boolean;
    classificationType: any;
    getClassificationType(feature: import("ol").Feature<import("ol/geom/Geometry").default>): import("@vcmap/cesium").ClassificationType | undefined;
    scaleByDistance: any;
    getScaleByDistance(feature: import("ol").Feature<import("ol/geom/Geometry").default>): import("@vcmap/cesium").NearFarScalar | undefined;
    eyeOffset: any;
    getEyeOffset(feature: import("ol").Feature<import("ol/geom/Geometry").default>): import("@vcmap/cesium").Cartesian3;
    heightAboveGround: any;
    getHeightAboveGround(feature: import("ol").Feature<import("ol/geom/Geometry").default>): number;
    skirt: any;
    getSkirt(feature: import("ol").Feature<import("ol/geom/Geometry").default>): number;
    groundLevel: any;
    getGroundLevel(feature: import("ol").Feature<import("ol/geom/Geometry").default>): number | undefined;
    extrudedHeight: any;
    getExtrudedHeight(feature: import("ol").Feature<import("ol/geom/Geometry").default>): number;
    storeysAboveGround: any;
    getStoreysAboveGround(feature: import("ol").Feature<import("ol/geom/Geometry").default>): number;
    storeysBelowGround: any;
    getStoreysBelowGround(feature: import("ol").Feature<import("ol/geom/Geometry").default>): number;
    storeyHeightsAboveGround: any;
    getStoreyHeightsAboveGround(feature: import("ol").Feature<import("ol/geom/Geometry").default>): number[];
    storeyHeightsBelowGround: any;
    getStoreyHeightsBelowGround(feature: import("ol").Feature<import("ol/geom/Geometry").default>): number[];
    storeyHeight: any;
    modelUrl: any;
    getModelUrl(feature: import("ol").Feature<import("ol/geom/Geometry").default>): string;
    modelScaleX: any;
    getModelScaleX(feature: import("ol").Feature<import("ol/geom/Geometry").default>): number;
    modelScaleY: any;
    getModelScaleY(feature: import("ol").Feature<import("ol/geom/Geometry").default>): number;
    modelScaleZ: any;
    getModelScaleZ(feature: import("ol").Feature<import("ol/geom/Geometry").default>): number;
    modelHeading: any;
    getModelHeading(feature: import("ol").Feature<import("ol/geom/Geometry").default>): number;
    modelPitch: any;
    getModelPitch(feature: import("ol").Feature<import("ol/geom/Geometry").default>): number;
    modelRoll: any;
    getModelRoll(feature: import("ol").Feature<import("ol/geom/Geometry").default>): number;
    modelOptions: any;
    /**
     * Get the features or the properties modelOptions. Returns an empty Object if both are undefined
     */
    getModelOptions(feature: import("ol").Feature<import("ol/geom/Geometry").default>): any;
    baseUrl: any;
    getBaseUrl(feature: import("ol").Feature<import("ol/geom/Geometry").default>): string;
    getModel(feature: import("ol").Feature<import("ol/geom/Geometry").default>): VectorPropertiesModelOptions | null;
    /**
     * resets values, either given, or default Value raises propertyChanged event once;
     */
    setVcsMeta(vcsMeta: VcsMeta): void;
    /**
     * sets given values only raises propertyChanged event if a value has been set;
     */
    setValues(options: VectorPropertiesOptions): void;
    getValues(): VectorPropertiesOptions;
    getVcsMeta(defaultOptions?: VectorPropertiesOptions): VcsMeta;
    /**
     * destroys the vectorProperties and removes all listeners
     */
    destroy(): void;
}

/**
 * Attached to a geometry to indicate, it is already in mercator and not the layers default projection
 */
export const alreadyTransformedToMercator: symbol;

/**
 * Attached to a geometry to indicate, it is already in oblique image coordiantes and not mercator
 */
export const alreadyTransformedToImage: symbol;

/**
 * Attached to an ol/Feature to reference the underlying oblique geometry
 */
export const obliqueGeometry: symbol;

/**
 * Attached to an ol/Feature which should only exist in oblqie coordinates and not be transformed to mercator on change
 */
export const doNotTransform: symbol;

/**
 * Attached to oblique features to reference the underlying original ol/Feature
 */
export const originalFeatureSymbol: symbol;

/**
 * Attached to mercator or oblique geometries which are polygons but have a circular counterpart. Used to not
 * mess up circle drawing in oblique
 */
export const actuallyIsCircle: symbol;

export function synchronizeFeatureVisibility(source: FeatureVisibility, destination: FeatureVisibility): (...params: any[]) => any;

/**
 */
export interface VectorTileOptions extends FeatureLayerOptions {
    tileProvider: TileProviderOptions | TileProvider;
    highlightStyle?: VectorStyleItemOptions | VectorStyleItem | undefined;
    vectorProperties?: VectorPropertiesOptions | undefined;
    /**
     * used to restrict the zoom level visibility (minlevel does not allow rendering above tileProvider baseLevel)
    */
    minLevel?: number | undefined;
    /**
     * used to restrict the zoom level visibility
    */
    maxLevel?: number | undefined;
}

export interface VectorTileImplementationOptions extends FeatureLayerImplementationOptions {
    tileProvider: TileProvider;
    tileSize: import("ol/size").Size;
    minLevel: number;
    maxLevel: number;
    extent?: Extent | undefined;
}

export interface VectorTileImplementation extends FeatureLayerImplementation {
    updateTiles: (...params: any[]) => any;
}

/**
 * VectorTileLayer Layer for tiled vector Data. Can be connected to data with a TileProvider
 */
export class VectorTileLayer extends FeatureLayer {
    constructor(options: VectorTileOptions);
    static readonly className: any;
    static getDefaultOptions(): VectorTileOptions;
    highlightStyle: VectorStyleItem;
    /**
     * at the moment only used for allowPicking, triggers a reload on change
     */
    vectorProperties: VectorProperties;
    tileProvider: TileProvider;
    /**
     * rerenders the specified tiles
     * rendering happens async
     */
    updateTiles(tileIds: string[]): void;
    /**
     * An event, called when the style of the layer changes. Is passed the new style item as its value.
     */
    styleChanged: VcsEvent<StyleItem>;
    /**
     * a height offset for rendering of a balloon for a feature of this layer.
     */
    balloonHeightOffset: number;
    /**
     * FeatureVisibility tracks the highlighting and hiding of features on this layer
     */
    featureVisibility: FeatureVisibility;
    /**
     * The style the layer had at construction
     */
    readonly defaultStyle: StyleItem;
    /**
     * style, use setStyle to change
     */
    readonly style: StyleItem;
    /**
     * Generic properties to be added to each feature. Use assignGenericFeatureProperties to change them.
     */
    readonly genericFeatureProperties: any;
    /**
     * Metadata on the extent of the data in this layer. Depending on the implementation, data is only requested
     * for this extent (e.g. {@see RasterLayer})
     */
    extent: Extent | null;
    /**
     * Whether this layer should be active on startup or not. Relevant for creating links.
     */
    activeOnStartup: boolean;
    /**
     * the names of the maps this layer is shown, all if empty
     */
    mapNames: string[];
    /**
     * The class names of the supported maps.
     */
    protected _supportedMaps: string[];
    /**
     * Called when the zIndex of this layer is changed. Is passed the new zIndex as its only argument.
     */
    zIndexChanged: VcsEvent<number>;
    /**
     * array of object Ids which should be hidden within the context of the layers layerCollection, if this layer is active
     */
    hiddenObjectIds: string[];
    /**
     * event raised if the exclusives group of the layer changes. is passed the array of exclusive groups as its only argument
     */
    exclusiveGroupsChanged: VcsEvent<(string | symbol)[]>;
    globalHider: GlobalHider;
    copyright: CopyrightOptions | undefined;
    /**
     * Event raised, if the layers state changes. Is passed the LayerState as its only parameter
     */
    stateChanged: VcsEvent<LayerState>;
    /**
     * An optional feature provider to provider features based on click events.
     */
    featureProvider: AbstractFeatureProvider;
    /**
     * True if this layer has been initialized, typically after its first activation.
     */
    readonly initialized: boolean;
    readonly active: boolean;
    readonly loading: boolean;
    readonly state: LayerState;
    allowPicking: boolean;
    /**
     * A layers url, should on be configured, else an empty string
     */
    url: string;
    /**
     * Indicates, that this layer is part of an exclusiveGroup
     */
    readonly exclusive: boolean;
    /**
     * An array of arbitrary exclusive groups
     */
    readonly exclusiveGroups: any;
    zIndex: number;
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
}

/**
 */
export interface WFSOptions extends VectorOptions {
    /**
     * required parameter of the featureType to load. Supply an array for multiples
    */
    featureType: string | string[];
    /**
     * required parameter, namespace used for the feature prefix
    */
    featureNS: string;
    /**
     * required parameter, feature prefix
    */
    featurePrefix: string;
    /**
     * additional config for [ol/format/WFS/writeGetFeature]{@link https://openlayers.org/en/latest/apidoc/ol.format.WFS.html} excluding featureType, featureNS and featurePrefix
    */
    getFeatureOptions?: any | undefined;
}

/**
 * WfsLayer VectorLayer Layer
 */
export class WFSLayer extends VectorLayer {
    constructor(options: WFSOptions);
    static getDefaultOptions(): WFSOptions;
    featureType: string[];
    featureNS: string;
    featurePrefix: string;
    getFeaturesOptions: any;
    wfsFormat: import("ol/format/WFS").default;
    /**
     * Fetches the data for the layer. If data is already fetched returns a resolved Promise
     */
    fetchData(): Promise<void>;
    source: import("ol/source").Vector<import("ol/geom/Geometry").default>;
    projection: Projection;
    maxResolution: number;
    minResolution: number;
    dontUseTerrainForOblique: boolean;
    highlightStyle: VectorStyleItem;
    /**
     * A flag to indicate, whether the features in the layer have a UUID, allowing certain interactions,
     * e.g. hidding its features in plannings
     */
    hasFeatureUUID: boolean;
    /**
     * If true, the cesium synchronizers are destroyed on map change
     */
    isDynamic: boolean;
    vectorProperties: VectorProperties;
    allowPicking: boolean;
    visibility: boolean;
    /**
     * An event, called when the style of the layer changes. Is passed the new style item as its value.
     */
    styleChanged: VcsEvent<StyleItem>;
    /**
     * a height offset for rendering of a balloon for a feature of this layer.
     */
    balloonHeightOffset: number;
    /**
     * FeatureVisibility tracks the highlighting and hiding of features on this layer
     */
    featureVisibility: FeatureVisibility;
    /**
     * The style the layer had at construction
     */
    readonly defaultStyle: StyleItem;
    /**
     * style, use setStyle to change
     */
    readonly style: StyleItem;
    /**
     * Generic properties to be added to each feature. Use assignGenericFeatureProperties to change them.
     */
    readonly genericFeatureProperties: any;
    /**
     * Metadata on the extent of the data in this layer. Depending on the implementation, data is only requested
     * for this extent (e.g. {@see RasterLayer})
     */
    extent: Extent | null;
    /**
     * Whether this layer should be active on startup or not. Relevant for creating links.
     */
    activeOnStartup: boolean;
    /**
     * the names of the maps this layer is shown, all if empty
     */
    mapNames: string[];
    /**
     * The class names of the supported maps.
     */
    protected _supportedMaps: string[];
    /**
     * Called when the zIndex of this layer is changed. Is passed the new zIndex as its only argument.
     */
    zIndexChanged: VcsEvent<number>;
    /**
     * array of object Ids which should be hidden within the context of the layers layerCollection, if this layer is active
     */
    hiddenObjectIds: string[];
    /**
     * event raised if the exclusives group of the layer changes. is passed the array of exclusive groups as its only argument
     */
    exclusiveGroupsChanged: VcsEvent<(string | symbol)[]>;
    globalHider: GlobalHider;
    copyright: CopyrightOptions | undefined;
    /**
     * Event raised, if the layers state changes. Is passed the LayerState as its only parameter
     */
    stateChanged: VcsEvent<LayerState>;
    /**
     * An optional feature provider to provider features based on click events.
     */
    featureProvider: AbstractFeatureProvider;
    /**
     * True if this layer has been initialized, typically after its first activation.
     */
    readonly initialized: boolean;
    readonly active: boolean;
    readonly loading: boolean;
    readonly state: LayerState;
    /**
     * A layers url, should on be configured, else an empty string
     */
    url: string;
    /**
     * Indicates, that this layer is part of an exclusiveGroup
     */
    readonly exclusive: boolean;
    /**
     * An array of arbitrary exclusive groups
     */
    readonly exclusiveGroups: any;
    zIndex: number;
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
}

/**
 */
export interface WMSSourceOptions {
    url: string;
    /**
     * either "geographic" or "mercator"
    */
    tilingSchema: string;
    maxLevel: number;
    minLevel: number;
    tileSize: import("ol/size").Size;
    extent?: Extent | undefined;
    parameters: {
        [key: string]: string;
    };
    version: string;
}

export function getWMSSource(options: WMSSourceOptions): import("ol/source/TileWMS").default;

export interface WMSImplementationOptions extends RasterLayerImplementationOptions {
    parameters: {
        [key: string]: any;
    };
    highResolution: boolean;
    tileSize: import("ol/size").Size;
    version: string;
}

/**
 */
export interface WMSOptions extends RasterLayerOptions {
    /**
     * string with comma separated names of the layers to display
    */
    layers?: string | undefined;
    /**
     * WMS version (either 1.1.1 (default) or 1.3.0)
    */
    version?: string;
    /**
     * key value pair of additional WMS parameters, url query notation possible
    */
    parameters?: {
        [key: string]: any;
    } | string | undefined;
    /**
     * whether this layer should send getFeatureInfo requests to the service when objects are clicked.
    */
    featureInfo?: WMSFeatureProviderOptions | undefined;
    tileSize?: import("ol/size").Size;
    /**
     * use higher resolution images (sofar only in 3D)
    */
    highResolution?: boolean;
}

/**
 * WmsLayer layer for Cesium and OpenlayersMap
 */
export class WMSLayer extends RasterLayer {
    constructor(options: WMSOptions);
    static getDefaultOptions(): WMSOptions;
    version: string;
    parameters: {
        [key: string]: any;
    };
    tileSize: import("ol/size").Size;
    highResolution: boolean;
    /**
     * Sets the layers to request from the WmsLayer
     * @param layers - a layer name or an array of layer names
     */
    setLayers(layers: string | string[]): Promise<void>;
    /**
     * Returns the currently active layers
     */
    getLayers(): string[];
    /**
     * The {@link RasterLayer.TilingScheme} of this layer
     */
    tilingSchema: string;
    maxLevel: number;
    minLevel: number;

    /**
     * raised if the split direction changes, is passed the split direction as its only argument
     */
    splitDirectionChanged: VcsEvent<import("@vcmap/cesium").SplitDirection>;
    /**
     * The split directions of this layer
     */
    splitDirection: import("@vcmap/cesium").SplitDirection;
    /**
     * The opacity between 0 (fully transparent) and 1 (fully opaque)
     */
    opacity: number;
    /**
     * Metadata on the extent of the data in this layer. Depending on the implementation, data is only requested
     * for this extent (e.g. {@see RasterLayer})
     */
    extent: Extent | null;
    /**
     * Whether this layer should be active on startup or not. Relevant for creating links.
     */
    activeOnStartup: boolean;
    /**
     * the names of the maps this layer is shown, all if empty
     */
    mapNames: string[];
    /**
     * The class names of the supported maps.
     */
    protected _supportedMaps: string[];
    /**
     * Called when the zIndex of this layer is changed. Is passed the new zIndex as its only argument.
     */
    zIndexChanged: VcsEvent<number>;
    /**
     * array of object Ids which should be hidden within the context of the layers layerCollection, if this layer is active
     */
    hiddenObjectIds: string[];
    /**
     * event raised if the exclusives group of the layer changes. is passed the array of exclusive groups as its only argument
     */
    exclusiveGroupsChanged: VcsEvent<(string | symbol)[]>;
    globalHider: GlobalHider;
    copyright: CopyrightOptions | undefined;
    /**
     * Event raised, if the layers state changes. Is passed the LayerState as its only parameter
     */
    stateChanged: VcsEvent<LayerState>;
    /**
     * An optional feature provider to provider features based on click events.
     */
    featureProvider: AbstractFeatureProvider;
    /**
     * True if this layer has been initialized, typically after its first activation.
     */
    readonly initialized: boolean;
    readonly active: boolean;
    readonly loading: boolean;
    readonly state: LayerState;
    allowPicking: boolean;
    /**
     * A layers url, should on be configured, else an empty string
     */
    url: string;
    /**
     * Indicates, that this layer is part of an exclusiveGroup
     */
    readonly exclusive: boolean;
    /**
     * An array of arbitrary exclusive groups
     */
    readonly exclusiveGroups: any;
    zIndex: number;
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
}

export interface WMTSOptions extends RasterLayerOptions {
    layer: string;
    style?: string | undefined;
    format?: string | undefined;
    tileMatrixSetID?: string | undefined;
    tileMatrixPrefix?: string | undefined;
    matrixIds: string[];
    numberOfLevelZeroTilesX?: number;
    numberOfLevelZeroTilesY?: number;
    openlayersOptions?: any | undefined;
    tileSize?: import("ol/size").Size;
}

export interface WMTSImplementationOptions extends RasterLayerImplementationOptions {
    layer: string;
    style: string;
    format: string;
    tileMatrixSetID: string;
    tileSize: import("ol/size").Size;
    numberOfLevelZeroTilesX: number;
    numberOfLevelZeroTilesY: number;
    matrixIds: string[];
    openlayersOptions: any;
}

/**
 * WmtsLayer layer
 */
export class WMTSLayer extends RasterLayer {
    constructor(options: WMTSOptions);
    static getDefaultOptions(): WMTSOptions;
    numberOfLevelZeroTilesX: number;
    numberOfLevelZeroTilesY: number;
    layer: string;
    style: string;
    format: string;
    tileMatrixPrefix: string;
    tileMatrixSetID: string;
    openlayersOptions: any;
    matrixIds: string[] | null;
    tileSize: import("ol/size").Size;
    /**
     * The {@link RasterLayer.TilingScheme} of this layer
     */
    tilingSchema: string;
    maxLevel: number;
    minLevel: number;

    /**
     * raised if the split direction changes, is passed the split direction as its only argument
     */
    splitDirectionChanged: VcsEvent<import("@vcmap/cesium").SplitDirection>;
    /**
     * The split directions of this layer
     */
    splitDirection: import("@vcmap/cesium").SplitDirection;
    /**
     * The opacity between 0 (fully transparent) and 1 (fully opaque)
     */
    opacity: number;
    /**
     * Metadata on the extent of the data in this layer. Depending on the implementation, data is only requested
     * for this extent (e.g. {@see RasterLayer})
     */
    extent: Extent | null;
    /**
     * Whether this layer should be active on startup or not. Relevant for creating links.
     */
    activeOnStartup: boolean;
    /**
     * the names of the maps this layer is shown, all if empty
     */
    mapNames: string[];
    /**
     * The class names of the supported maps.
     */
    protected _supportedMaps: string[];
    /**
     * Called when the zIndex of this layer is changed. Is passed the new zIndex as its only argument.
     */
    zIndexChanged: VcsEvent<number>;
    /**
     * array of object Ids which should be hidden within the context of the layers layerCollection, if this layer is active
     */
    hiddenObjectIds: string[];
    /**
     * event raised if the exclusives group of the layer changes. is passed the array of exclusive groups as its only argument
     */
    exclusiveGroupsChanged: VcsEvent<(string | symbol)[]>;
    globalHider: GlobalHider;
    copyright: CopyrightOptions | undefined;
    /**
     * Event raised, if the layers state changes. Is passed the LayerState as its only parameter
     */
    stateChanged: VcsEvent<LayerState>;
    /**
     * An optional feature provider to provider features based on click events.
     */
    featureProvider: AbstractFeatureProvider;
    /**
     * True if this layer has been initialized, typically after its first activation.
     */
    readonly initialized: boolean;
    readonly active: boolean;
    readonly loading: boolean;
    readonly state: LayerState;
    allowPicking: boolean;
    /**
     * A layers url, should on be configured, else an empty string
     */
    url: string;
    /**
     * Indicates, that this layer is part of an exclusiveGroup
     */
    readonly exclusive: boolean;
    /**
     * An array of arbitrary exclusive groups
     */
    readonly exclusiveGroups: any;
    zIndex: number;
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
}

/**
 * OpenlayersMap Map base map.
 */
export class BaseOLMap extends VcsMap {
    constructor(options: VcsMapOptions);
    readonly olMap: any;
    /**
     * Internal API for registering representations.
     */
    addOLLayer(olLayer: import("ol/layer/Layer").default<import("ol/source").Source>): void;
    /**
     * Internal API for deregistering representations.
     */
    removeOLLayer(olLayer: import("ol/layer/Layer").default<import("ol/source").Source>): void;
    mapElement: HTMLElement;
    /**
     * Whether to destroy the layerCollection when destroying the map. Defaults to
     * false if passing in a LayerCollection and true if a LayerCollection is created.
     * Is set to false, when setting a different LayerCollection.
     */
    destroyLayerCollection: boolean;
    initialized: boolean;
    /**
     * if true, no movements should occur
     */
    movementDisabled: boolean;
    /**
     * The name of a map to fall back on, if this map cant show a viewpoint
     */
    fallbackMap: string | null;
    /**
     * Event raised when the maps state changes. Is passed the {@link MapState} as its only argument.
     */
    stateChanged: VcsEvent<MapState>;
    /**
     * Event raised then the map has a pointer interaction. Raises {@link MapEvent}.
     */
    pointerInteractionEvent: VcsEvent<MapEvent>;
    /**
     * If present, the split screen to use on this map. Is set by the mapCollection
     */
    splitScreen: SplitScreen | null;
    /**
     * Whether the map is active or not
     */
    readonly active: boolean;
    /**
     * Whether the map is loading or not
     */
    readonly loading: boolean;
    /**
     * The currently set HTML element in which to render the map
     */
    readonly target: HTMLElement | null;
    /**
     * The layer collection of this map. LayerCollections can be shared among maps.
     * When adding the map to a {@link MapCollection}, the layer collection of the {@link MapCollection} will be set.
     * When setting the layer colleciton, the destroyLayerCollection flag is automatically set to false.
     */
    layerCollection: LayerCollection;
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
}

/**
 */
export interface CameraLimiterOptions {
    /**
     * required if mode is distance.
    */
    terrainUrl?: string | undefined;
    /**
     * either "height" or "distance".
    */
    mode?: string | undefined;
    limit?: number;
    /**
     * the level at which to request terrain data. setting this to null will request most detailed
    */
    level?: number | null;
}

/**
 * Enumeration of camera limiter modes.
 */
export const enum CameraLimiterMode {
    HEIGHT,
    DISTANCE
}

/**
 * Can limit a Cesium.Cameras position based on absolute height or distance to a given terrain
 */
export class CameraLimiter {
    constructor(options: CameraLimiterOptions);
    static getDefaultOptions(): CameraLimiterOptions;
    /**
     * The mode to use. When using DISTANCE mode, be sure to have a terrainProvider set.
     */
    mode: CameraLimiterMode;
    /**
     * The minimum height/distance to the terrain the camera must maintain
     */
    limit: number;
    /**
     * The level to request terrain data at
     */
    level: number | null;
    /**
     * last checked camera position
     */
    lastCheckedPosition: import("@vcmap/cesium").Cartographic;
    terrainUrl: any;
    /**
     * Limits the given camera based on this limiters specs.
     */
    limitCamera(camera: import("@vcmap/cesium").Camera): Promise<void>;
    toJSON(): CameraLimiterOptions;
}

/**
 */
export interface CesiumMapOptions extends VcsMapOptions {
    /**
     * if true, lighting will be activated.
    */
    enableLightning?: boolean;
    /**
     * the tilecache size of cesium terrain and tile layer
    */
    tileCacheSize?: number;
    /**
     * activates webGL antialiasing (not every Browser respects this value)
    */
    webGLaa?: boolean;
    cameraLimiter?: CameraLimiterOptions | undefined;
    /**
     * the color of the globe, if no image is provided
    */
    globeColor?: string | undefined;
}

/**
 * Cesium Globe Map Class (3D map)
 */
export class CesiumMap extends VcsMap {
    constructor(options: CesiumMapOptions);
    static getDefaultOptions(): CesiumMapOptions;
    /**
     * clock for animated data
     */
    dataSourceDisplayClock: import("@vcmap/cesium").Clock;
    /**
     * Whether the debug mode is active or not
     */
    debugMode: boolean;
    enableLightning: boolean;
    tileCacheSize: number;
    screenSpaceEventHandler: import("@vcmap/cesium").ScreenSpaceEventHandler;
    defaultJDate: import("@vcmap/cesium").JulianDate;
    webGLaa: boolean;
    globeColor: import("@vcmap/cesium").Color;

    defaultTerrainProvider: import("@vcmap/cesium").TerrainProvider;
    readonly terrainProvider: any;
    cameraLimiter: any;
    debug: any;
    dataSourceDisplay: import("@vcmap/cesium").DataSourceDisplay;
    /**
     * getHeight for coordinates
     * @param positions - in web mercator
     * @returns the array of coordinates with heights updated in place
     */
    getHeightFromTerrain(positions: import("ol/coordinate").Coordinate[]): Promise<import("ol/coordinate").Coordinate[]>;
    /**
     * set dataSource clock as display clock to visualize time dependent animation
     */
    setDataSourceDisplayClock(clock: import("@vcmap/cesium").DataSourceClock): void;
    /**
     * unset dataSource clock
     */
    unsetDataSourceDisplayClock(clock: import("@vcmap/cesium").DataSourceClock): void;
    /**
     * sets the position of the sun according to the day
     * @param julianDate - See the Cesium API
     */
    setDay(julianDate: import("@vcmap/cesium").JulianDate): void;
    /**
     * sets the lighting of the globe with the sun as a light source
     */
    setLightning(value: boolean): void;
    /**
     * returns the cesium Widget Object
     */
    getCesiumWidget(): import("@vcmap/cesium").CesiumWidget;
    /**
     * returns the Entities Collection
     */
    getEntities(): import("@vcmap/cesium").EntityCollection;
    /**
     * returns the dataSourceCollection associated with the scene
     */
    getDatasources(): import("@vcmap/cesium").DataSourceCollection;
    /**
     * Returns the cluster dataSourceDisplays dataSources.
     * This datasource can only handle Entities with Billboards, Labels or Points.
     */
    getClusterDatasources(): import("@vcmap/cesium").DataSourceCollection;
    /**
     * Internal API used to register visualizations from layer implementations
     */
    addPrimitiveCollection(primitiveCollection: import("@vcmap/cesium").PrimitiveCollection | import("@vcmap/cesium").Cesium3DTileset): void;
    /**
     * Internal API to unregister the visualization for a layers implementation
     */
    removePrimitiveCollection(primitiveCollection: import("@vcmap/cesium").PrimitiveCollection): void;
    /**
     * Internal API used to register visualizations from layer implementations
     */
    addImageryLayer(imageryLayer: import("@vcmap/cesium").ImageryLayer): void;
    /**
     * Internal API used to unregister visualizations from layer implementations
     */
    removeImageryLayer(imageryLayer: import("@vcmap/cesium").ImageryLayer): void;
    /**
     * Internal API used to register visualizations from layer implementations
     */
    addDataSource(dataSource: import("@vcmap/cesium").CustomDataSource): Promise<void>;
    /**
     * Internal API used to unregister visualizations from layer implementations
     */
    removeDataSource(dataSource: import("@vcmap/cesium").CustomDataSource): void;
    /**
     * set the cesium TerrainProvider
     */
    setTerrainProvider(terrainProvider: import("@vcmap/cesium").TerrainProvider): void;
    /**
     * unsets the TerrainProvider (changes to the default TerrainProvider if the given terranProvider is currently active)
     */
    unsetTerrainProvider(terrainProvider: import("@vcmap/cesium").TerrainProvider): void;
    /**
     * returns the cesium DataSourceDisplay Object
     */
    getDataSourceDisplay(): import("@vcmap/cesium").DataSourceDisplay;
    /**
     * returns the cesium Scene Object, returns null on non initialized or destroyed maps
     */
    getScene(): import("@vcmap/cesium").Scene;
    /**
     * returns true if the WEBGL Extension WEBGL_depth_texture is supported. (Is used for picking)
     */
    pickPositionSupported(): any;
    /**
     * returns true if the WEBGL Extension EXT_frag_depth is supported. (Is used for GroundPoloygons)
     */
    isGroundPrimitiveSupported(): any;
    mapElement: HTMLElement;
    /**
     * Whether to destroy the layerCollection when destroying the map. Defaults to
     * false if passing in a LayerCollection and true if a LayerCollection is created.
     * Is set to false, when setting a different LayerCollection.
     */
    destroyLayerCollection: boolean;
    initialized: boolean;
    /**
     * if true, no movements should occur
     */
    movementDisabled: boolean;
    /**
     * The name of a map to fall back on, if this map cant show a viewpoint
     */
    fallbackMap: string | null;
    /**
     * Event raised when the maps state changes. Is passed the {@link MapState} as its only argument.
     */
    stateChanged: VcsEvent<MapState>;
    /**
     * Event raised then the map has a pointer interaction. Raises {@link MapEvent}.
     */
    pointerInteractionEvent: VcsEvent<MapEvent>;
    /**
     * If present, the split screen to use on this map. Is set by the mapCollection
     */
    splitScreen: SplitScreen | null;
    /**
     * Whether the map is active or not
     */
    readonly active: boolean;
    /**
     * Whether the map is loading or not
     */
    readonly loading: boolean;
    /**
     * The currently set HTML element in which to render the map
     */
    readonly target: HTMLElement | null;
    /**
     * The layer collection of this map. LayerCollections can be shared among maps.
     * When adding the map to a {@link MapCollection}, the layer collection of the {@link MapCollection} will be set.
     * When setting the layer colleciton, the destroyLayerCollection flag is automatically set to false.
     */
    layerCollection: LayerCollection;
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
}

/**
 * The state of a map.
 * State machine: inactive <-> loading -> active -> inactive
 */
export const enum MapState {
    INACTIVE = 1,
    ACTIVE = 2,
    LOADING = 4
}

export interface ObliqueClickParameters {
    pixel: import("ol/pixel").Pixel;
    estimate?: boolean | undefined;
}

export interface ObliqueOptions extends VcsMapOptions {
    changeOnMoveEnd?: boolean;
    switchThreshold?: number;
    switchOnEdge?: boolean;
}

/**
 * returns the direction which matches the heading of the viewpoint
 */
export function getViewDirectionFromViewPoint(viewpoint: ViewPoint): ObliqueViewDirection;

/**
 * ObliqueMap Map Class (2D map with oblique imagery)
 */
export class ObliqueMap extends BaseOLMap {
    static getDefaultOptions(): ObliqueOptions;

    /**
     * An event raise, when the collection changes. Is passed the collection as its only argument.
     */
    collectionChanged: VcsEvent<ObliqueCollection>;
    switchEnabled: any;
    switchThreshold: any;
    mapChangeEvent: any;
    readonly collection: ObliqueCollection;
    readonly imageChanged: VcsEvent<ObliqueImage>;
    readonly currentImage: ObliqueImage | null;
    getExtentOfCurrentImage(): Extent;
    /**
     * Sets a new oblique collection
     */
    setCollection(obliqueCollection: ObliqueCollection, viewpoint?: ViewPoint): Promise<void>;
    /**
     * Sets an image by its name on the map
     */
    setImageByName(imageName: string, optCenter?: import("ol/coordinate").Coordinate): Promise<void>;
    readonly olMap: any;
    mapElement: HTMLElement;
    /**
     * Whether to destroy the layerCollection when destroying the map. Defaults to
     * false if passing in a LayerCollection and true if a LayerCollection is created.
     * Is set to false, when setting a different LayerCollection.
     */
    destroyLayerCollection: boolean;
    initialized: boolean;
    /**
     * if true, no movements should occur
     */
    movementDisabled: boolean;
    /**
     * The name of a map to fall back on, if this map cant show a viewpoint
     */
    fallbackMap: string | null;
    /**
     * Event raised when the maps state changes. Is passed the {@link MapState} as its only argument.
     */
    stateChanged: VcsEvent<MapState>;
    /**
     * Event raised then the map has a pointer interaction. Raises {@link MapEvent}.
     */
    pointerInteractionEvent: VcsEvent<MapEvent>;
    /**
     * If present, the split screen to use on this map. Is set by the mapCollection
     */
    splitScreen: SplitScreen | null;
    /**
     * Whether the map is active or not
     */
    readonly active: boolean;
    /**
     * Whether the map is loading or not
     */
    readonly loading: boolean;
    /**
     * The currently set HTML element in which to render the map
     */
    readonly target: HTMLElement | null;
    /**
     * The layer collection of this map. LayerCollections can be shared among maps.
     * When adding the map to a {@link MapCollection}, the layer collection of the {@link MapCollection} will be set.
     * When setting the layer colleciton, the destroyLayerCollection flag is automatically set to false.
     */
    layerCollection: LayerCollection;
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
}

/**
 */
export interface OpenlayersOptions extends VcsMapOptions {
    /**
     * sets whether the openlayers map has a fixed orientation towards north (default true)
    */
    fixedNorthOrientation?: boolean;
}

/**
 * OpenlayersMap Map Class (2D map)
 */
export class OpenlayersMap extends BaseOLMap {
    constructor(options: OpenlayersOptions);
    static className: string;
    static getDefaultOptions(): OpenlayersOptions;
    fixedNorthOrientation: boolean;
    readonly olMap: any;
    mapElement: HTMLElement;
    /**
     * Whether to destroy the layerCollection when destroying the map. Defaults to
     * false if passing in a LayerCollection and true if a LayerCollection is created.
     * Is set to false, when setting a different LayerCollection.
     */
    destroyLayerCollection: boolean;
    initialized: boolean;
    /**
     * if true, no movements should occur
     */
    movementDisabled: boolean;
    /**
     * The name of a map to fall back on, if this map cant show a viewpoint
     */
    fallbackMap: string | null;
    /**
     * Event raised when the maps state changes. Is passed the {@link MapState} as its only argument.
     */
    stateChanged: VcsEvent<MapState>;
    /**
     * Event raised then the map has a pointer interaction. Raises {@link MapEvent}.
     */
    pointerInteractionEvent: VcsEvent<MapEvent>;
    /**
     * If present, the split screen to use on this map. Is set by the mapCollection
     */
    splitScreen: SplitScreen | null;
    /**
     * Whether the map is active or not
     */
    readonly active: boolean;
    /**
     * Whether the map is loading or not
     */
    readonly loading: boolean;
    /**
     * The currently set HTML element in which to render the map
     */
    readonly target: HTMLElement | null;
    /**
     * The layer collection of this map. LayerCollections can be shared among maps.
     * When adding the map to a {@link MapCollection}, the layer collection of the {@link MapCollection} will be set.
     * When setting the layer colleciton, the destroyLayerCollection flag is automatically set to false.
     */
    layerCollection: LayerCollection;
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
}

/**
 */
export interface VcsMapOptions extends VcsObjectOptions {
    /**
     * the name of the fallback map to use, e.g. in case there is no oblique image at the activation viewpoint
    */
    fallbackMap?: string | undefined;
    /**
     * layerCollection to use, if not provided an empty Collection will be created.
    */
    layerCollection?: LayerCollection | undefined;
    /**
     * the HTMLElement to render the map into
    */
    target?: string | HTMLElement | undefined;
}

export interface ClickPosition {
    latitude: number;
    longitude: number;
    height?: number | undefined;
    groundLevel?: number | undefined;
    obliqueParameters?: ObliqueClickParameters | undefined;
    exactPosition?: boolean | undefined;
}

/**
 * Map Base Class, each different map is derived from this abstract base class.
 */
export class VcsMap extends VcsObject {
    constructor(options: VcsMapOptions);
    static getDefaultOptions(): VcsMapOptions;
    mapElement: HTMLElement;
    /**
     * Whether to destroy the layerCollection when destroying the map. Defaults to
     * false if passing in a LayerCollection and true if a LayerCollection is created.
     * Is set to false, when setting a different LayerCollection.
     */
    destroyLayerCollection: boolean;
    initialized: boolean;
    /**
     * if true, no movements should occur
     */
    movementDisabled: boolean;
    /**
     * The name of a map to fall back on, if this map cant show a viewpoint
     */
    fallbackMap: string | null;
    /**
     * Event raised when the maps state changes. Is passed the {@link MapState} as its only argument.
     */
    stateChanged: VcsEvent<MapState>;
    /**
     * Event raised then the map has a pointer interaction. Raises {@link MapEvent}.
     */
    pointerInteractionEvent: VcsEvent<MapEvent>;
    /**
     * If present, the split screen to use on this map. Is set by the mapCollection
     */
    splitScreen: SplitScreen | null;
    /**
     * Whether the map is active or not
     */
    readonly active: boolean;
    /**
     * Whether the map is loading or not
     */
    readonly loading: boolean;
    /**
     * The currently set HTML element in which to render the map
     */
    readonly target: HTMLElement | null;
    layerCollection: any;
    /**
     * Determines whether this map can show this viewpoint. Returns true in any other map then {@link Oblique}
     */
    canShowViewpoint(viewpoint: ViewPoint): Promise<boolean>;
    /**
     * Sets the map target.
     */
    setTarget(target: string | HTMLElement | null): void;
    initialize(): Promise<void>;
    /**
     * is called if a layer changes its position in the layerCollection.
     */
    indexChanged(layer: Layer): void;
    /**
     * Validates a visualization. A visualization must have the vcsLayeName symbol set and a layer with said name must be
     * part of the maps layerCollection.
     */
    validateVisualization(item: import("@vcmap/cesium").CustomDataSource | import("@vcmap/cesium").PrimitiveCollection | import("@vcmap/cesium").Cesium3DTileset | import("@vcmap/cesium").ImageryLayer | import("ol/layer/Layer").default<import("ol/source").Source>): boolean;
    /**
     * Adds a visualization to the visualizations map for its layer. The visualization must be valid, use validateVisualization first
     */
    addVisualization(item: import("@vcmap/cesium").CustomDataSource | import("@vcmap/cesium").PrimitiveCollection | import("@vcmap/cesium").Cesium3DTileset | import("@vcmap/cesium").ImageryLayer | import("ol/layer/Layer").default<import("ol/source").Source>): void;
    /**
     * Removes a visualization
     */
    removeVisualization(item: import("@vcmap/cesium").PrimitiveCollection | import("@vcmap/cesium").Cesium3DTileset | import("@vcmap/cesium").ImageryLayer | import("ol/layer/Layer").default<import("ol/source").Source> | import("@vcmap/cesium").CustomDataSource): void;
    /**
     * Gets the visualizations for a specific layer.
     */
    getVisualizationsForLayer(layer: Layer): Set<import("@vcmap/cesium").PrimitiveCollection | import("@vcmap/cesium").Cesium3DTileset | import("@vcmap/cesium").ImageryLayer | import("ol/layer/Layer").default<import("ol/source").Source> | import("@vcmap/cesium").CustomDataSource>;
    /**
     * Get all visualizations added to this map.
     */
    getVisualizations(): (import("@vcmap/cesium").PrimitiveCollection | import("@vcmap/cesium").Cesium3DTileset | import("@vcmap/cesium").ImageryLayer | import("ol/layer/Layer").default<import("ol/source").Source> | import("@vcmap/cesium").CustomDataSource)[];
    /**
     * activates the map, if necessary initializes the map.
     * Once the promise resolves, the map can still be inactive, if deactivate was called while the map was activating.
     */
    activate(): Promise<void>;
    /**
     * deactivates the map
     */
    deactivate(): void;
    /**
     * prevent all movement, including navigation controls, gotoViewPoint & setting of oblique images
     */
    disableMovement(prevent: boolean): void;
    /**
     * sets the view to the given viewpoint
     * @param [optMaximumHeight] - during animation (can be used to get rid of the bunny hop)
     * gotoViewPoint
     */
    gotoViewPoint(viewpoint: ViewPoint, optMaximumHeight?: number): Promise<void>;
    /**
     * Returns the most precise viewpoint possible in ObliqueMap.
     */
    getViewPoint(): Promise<ViewPoint | null>;
    /**
     * Returns an approximate viewpoint in ObliqueMap, not requesting terrain.
     */
    getViewPointSync(): ViewPoint | null;
    /**
     * Resolution in meters per pixe
     * @param coordinate - coordinate in mercator for which to determine resolution. only required in 3D
     */
    getCurrentResolution(coordinate: import("ol/coordinate").Coordinate): number;
    /**
     * @param coords - in WGS84 degrees
     */
    pointIsVisible(coords: import("ol/coordinate").Coordinate): boolean;
    /**
     * Requests this map to render when possible
     */
    requestRender(): void;
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
}

/**
 * This is a special oblique collection wich is shown, if no other oblique collection is set on an ObliqueMap map.
 * It will render a single image which indicates that no images can be loaded.
 */
export class DefaultObliqueCollection extends ObliqueCollection {
    viewOptions: ObliqueViewOptions;

    /**
     * Event raised when images are loaded. Is passed an Array of ObliqueImages as its only argument.
     */
    imagesLoaded: VcsEvent<ObliqueImage[]>;
    /**
     * Whether to activate this collection after loading its defining context.
     */
    activeOnStartup: boolean;
    readonly dataSets: ObliqueDataSet[];
    /**
     * Indicates, that this collection has been loaded
     */
    loaded: boolean;
    destroyed: any;
    /**
     * A vector source of all tiles available to this collection in mercator. The feature have a "state" property,
     * the id is the string tile coordinate "z/x/y" of the tile
     */
    readonly tileFeatureSource: import("ol/source/Vector").default<import("ol/geom/Geometry").default>;
    /**
     * A vector source of all image currently loaded for this collection in mercator.
     * The id is the image name. The feature has a "viewDirection" property.
     */
    readonly imageFeatureSource: import("ol/source/Vector").default<import("ol/geom/Geometry").default>;
    /**
     * All currently loaded images
     */
    readonly images: ObliqueImage[];
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
}

export interface PickTerrainReturn {
    estimate: boolean;
    coords: import("ol/coordinate").Coordinate;
}

/**
 * sorts the corner points of the json after [lower left, lower right, upper right, upper left]
 * 3----2   ^
 * |    |   |
 * 0----1 north
 */
export function sortRealWordEdgeCoordinates(inputCornerPoints: import("ol/coordinate").Coordinate[], sortDirection?: ObliqueViewDirection | boolean): import("ol/coordinate").Coordinate[];

/**
 * taken from http://jsfiddle.net/justin_c_rounds/Gd2S2/
 */
export function checkLineIntersection(segment1: import("ol/coordinate").Coordinate[], segment2: import("ol/coordinate").Coordinate[]): any;

/**
 * transforms coordinate with intersection from corner
 */
export function transformCWIFC(inputOrigin: import("ol/coordinate").Coordinate[], inputTarget: import("ol/coordinate").Coordinate[], originIsImage: boolean, coordinate2Transform: import("ol/coordinate").Coordinate, viewDirection: ObliqueViewDirection): any | null;

/**
 */
export interface ImageTransformationOptions {
    dontUseTerrain?: boolean | undefined;
    /**
     * the projection of the input/output coordinates, assumes image source projection
    */
    dataProjection?: Projection | undefined;
    /**
     * the transformToWorld process iterativly calculates a new Height Value from the terrainProvider until the difference to the new height value is smaller
    */
    terrainErrorThreshold?: number | undefined;
    /**
     * how often the  transformToWorld process iterativly calculates a new Height Value from the terrainProvider
    */
    terrainErrorCountThreshold?: number | undefined;
}

/**
 * Always returns a Promise. When the input coordinates contain a height, it will use this height to compute the image coordinates
 * When not, it will try to get the terrainHeight in case a terrain is defined and use the height from there, to compute the image coordinates
 * @param worldCoordinate - if not in web mercatpr, specify data-projection in options
 */
export function transformToImage(image: ObliqueImage, worldCoordinate: import("ol/coordinate").Coordinate, options?: ImageTransformationOptions): Promise<{ coords: import("ol/coordinate").Coordinate; height: number; estimate: boolean | undefined; }>;

export interface PickTerrainOptions {
    image: ObliqueImage;
    worldCoordinate: import("ol/coordinate").Coordinate;
    imageCoordinate: import("ol/coordinate").Coordinate;
    height: number;
    terrainErrorThreshold: number;
    terrainErrorCountThreshold: number;
    count: number;
}

/**
 * Always returns a deferred.
 * it will try to get the terrainHeight in case a terrain is defined.
 * @returns return coordinates are in mercator if not specified in options
 */
export function transformFromImage(image: ObliqueImage, imageCoordinate: import("ol/coordinate").Coordinate, options?: ImageTransformationOptions): Promise<PickTerrainReturn>;

export function hasSameOrigin(url: string): boolean;

export interface ObliqueCameraOptions {
    name: string;
    "principal-point": import("ol/coordinate").Coordinate;
    "pixel-size"?: import("ol/coordinate").Coordinate | undefined;
    "radial-distorsion-expected-2-found"?: number[] | undefined;
    "radial-distorsion-found-2-expected"?: number[] | undefined;
    size?: import("ol/size").Size | undefined;
}

export interface ObliqueGeneralImageInfo {
    width: number;
    height: number;
    "tile-resolution": number[];
    "tile-width": number;
    "tile-height": number;
    cameraParameter?: ObliqueCameraOptions[] | undefined;
    crs: string;
}

/**
 * The data within an image.json
 */
export interface ObliqueImageJson {
    generalImageInfo: ObliqueGeneralImageInfo;
    tileLevel?: number | undefined;
    images?: any[][] | undefined;
    availableTiles?: string[] | undefined;
}

export interface ObliqueVersion {
    version: number;
    buildNumber: number;
}

export interface ObliqueDataSetOptions {
    url: string;
    projection?: ProjectionOptions;
    terrainProvider?: TerrainProviderOptions;
}

export interface ObliqueCollectionOptions extends VcsObjectOptions {
    dataSets?: (ObliqueDataSet | ObliqueDataSetOptions)[];
    maxZoom?: number | undefined;
    minZoom?: number | undefined;
    scaleFactor?: number | undefined;
    hideLevels?: number | undefined;
    activeOnStartup?: boolean | undefined;
}

export class ObliqueCollection extends VcsObject {
    constructor(options: ObliqueCollectionOptions);
    static getDefaultOptions(): ObliqueCollectionOptions;
    viewOptions: ObliqueViewOptions;

    /**
     * Event raised when images are loaded. Is passed an Array of ObliqueImages as its only argument.
     */
    imagesLoaded: VcsEvent<ObliqueImage[]>;
    /**
     * Whether to activate this collection after loading its defining context.
     */
    activeOnStartup: boolean;
    readonly dataSets: ObliqueDataSet[];
    /**
     * Indicates, that this collection has been loaded
     */
    loaded: boolean;
    destroyed: any;
    /**
     * A vector source of all tiles available to this collection in mercator. The feature have a "state" property,
     * the id is the string tile coordinate "z/x/y" of the tile
     */
    readonly tileFeatureSource: import("ol/source/Vector").default<import("ol/geom/Geometry").default>;
    /**
     * A vector source of all image currently loaded for this collection in mercator.
     * The id is the image name. The feature has a "viewDirection" property.
     */
    readonly imageFeatureSource: import("ol/source/Vector").default<import("ol/geom/Geometry").default>;
    /**
     * All currently loaded images
     */
    readonly images: ObliqueImage[];
    /**
     * Adds an oblique data set to this collection.
     */
    addDataSet(dataSet: ObliqueDataSet): Promise<void>;
    /**
     * Loads all meta data associated with this collection
     */
    load(): Promise<void>;
    /**
     * Gets all available tile coordinates across all data sets, including their loaded state. Return value is
     * an object, where the key is the tile coordinate in z/x/y and the value is the data state
     */
    getTiles(): {
        [key: string]: DataState;
    };
    /**
     * Returns an image by its name, if it has been loaded
     */
    getImageByName(name: string): ObliqueImage;
    /**
     * Returns a list of viewDirections which a currently available in this collection
     */
    getAvailableViewDirections(): ObliqueViewDirection[];
    /**
     * Returns the state of the data for a given location an all underlying data sources
     * @param mercatorCoordinate - coordinate in web mercator
     */
    getDataStateForCoordinate(mercatorCoordinate: import("ol/coordinate").Coordinate): DataState;
    /**
     * Returns the state of the data for a given location an all underlying data sources
     * @param extent - coordinate in web mercator
     */
    getDataStateForExtent(extent: import("ol/coordinate").Coordinate): DataState;
    /**
     * Loads data for a given mercator Coordinate
     * @param mercatorCoordinate - coordinate in web mercator
     */
    loadDataForCoordinate(mercatorCoordinate: import("ol/coordinate").Coordinate): Promise<void>;
    /**
     * Loads all data tiles in the given extent
     */
    loadDataForExtent(extent: import("ol/extent").Extent): Promise<void>;
    /**
     * Returns the <i>closest</i> image for the given location and direction (location and image extent must not overlap).
     * Returns undefined, if there are no images for the given direction
     * @param mercatorCoordinate - coordinate in web mercator
     * @param direction - the preferred direction if no image in that direction can be found, other direction will be queried
     */
    getImageForCoordinate(mercatorCoordinate: import("ol/coordinate").Coordinate, direction: ObliqueViewDirection): ObliqueImage | undefined;
    /**
     * Loads all data for a location and then returns the <i>closest</i> image for the given location and direction (location and image extent must not overlap).
     * Returns undefined, if there are no images for the given direction
     * @param mercatorCoordinate - coordinate in web mercator
     */
    loadImageForCoordinate(mercatorCoordinate: import("ol/coordinate").Coordinate, direction: ObliqueViewDirection): Promise<ObliqueImage | undefined>;
    /**
     * Checks, if an image exists for a given coordinated
     * @param mercatorCoordinate - coordinate in web mercator
     */
    hasImageAtCoordinate(mercatorCoordinate: import("ol/coordinate").Coordinate, direction: ObliqueViewDirection): Promise<boolean>;
    /**
     * Loads the image adjacent to a given image in a certain direction from the provided image.
     * Returns undefined if there are no images in that direction or there are no images for the direction
     * of the provided image.
     * @param heading - 0 = east, PI / 2 = north, PI = west and PI * 1.5 = south
     */
    loadAdjacentImage(image: ObliqueImage, heading: number, deviation?: number): Promise<ObliqueImage | undefined>;
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
}

/**
 */
export interface ObliqueDataSetImagesLoaded {
    /**
     * the loaded images
    */
    images: ObliqueImage[];
    /**
     * an optional tile coordinate
    */
    tileCoordinate?: string;
}

/**
 * Enumeration of data set states
 */
export const enum DataState {
    PENDING,
    LOADING,
    READY
}

export function getStateFromStatesArray(states: DataState[]): DataState;

export class ObliqueDataSet {
    constructor(url: string, projection: Projection | ProjectionOptions, terrainProviderOptions?: TerrainProviderOptions);
    url: string;
    baseUrl: string;
    projection: Projection;
    /**
     * Event raised when images are loaded.
     */
    imagesLoaded: VcsEvent<ObliqueDataSetImagesLoaded>;



    copyright: CopyrightOptions | undefined;
    /**
     * The loaded images of this DataSet
     */
    readonly images: ObliqueImage[];
    /**
     * Gets the state of the meta data information. For tiled data sets, this does not
     * reflect the state of loaded tiles.
     */
    readonly state: DataState;
    readonly terrainProvider: import("@vcmap/cesium").CesiumTerrainProvider | undefined;
    /**
     * Loads the data set.
     */
    load(): Promise<void>;
    /**
     * Returns all tiles of this data set, including its DataState
     */
    getTiles(): {
        [key: string]: DataState;
    };
    /**
     * initialize the DataSet with an existing Object.
     * DataSets cannot be initialized more then once.
     */
    initialize(json: ObliqueImageJson): void;
    /**
     * Requests the state of data at a certain location. No data is automatically READY.
     * @param mercatorCoordinate - coordinate in web mercator
     */
    getDataStateForCoordinate(mercatorCoordinate: import("ol/coordinate").Coordinate): DataState;
    /**
     * Loads all the tiles for a given extent.
     */
    getDataStateForExtent(extent: import("ol/extent").Extent): DataState;
    /**
     * Loads the closest data tile for a certain location. Resolves when all data for the location has been loaded.
     * @param mercatorCoordinate - coordinate in web mercator
     */
    loadDataForCoordinate(mercatorCoordinate: import("ol/coordinate").Coordinate): Promise<void>;
    /**
     * Loads all the tiles for a given extent.
     */
    loadDataForExtent(extent: import("ol/extent").Extent): Promise<void>;
    toJSON(): ObliqueDataSetOptions;
}

export interface ObliqueImageOptions {
    name: string;
    viewDirection: ObliqueViewDirection;
    viewDirectionAngle: number;
    groundCoordinates: import("ol/coordinate").Coordinate[];
    centerPointOnGround: import("ol/coordinate").Coordinate;
    meta: ObliqueImageMeta;
    projectionCenter?: import("@vcmap/cesium").Cartesian3 | undefined;
    pToRealworld?: import("@vcmap/cesium").Matrix3 | undefined;
    pToImage?: import("@vcmap/cesium").Matrix4 | undefined;
    projection?: Projection | undefined;
    terrainProvider?: import("@vcmap/cesium").CesiumTerrainProvider | undefined;
}

export class ObliqueImage {
    constructor(options: ObliqueImageOptions);
    /**
     * Name of the image
     */
    name: string;
    /**
     * Meta information shared across multiple images.
     */
    meta: ObliqueImageMeta;
    /**
     * viewDirection
     */
    viewDirection: ObliqueViewDirection;
    /**
     * viewDirectionAngle in radians, where 0 = east, PI / 2 = north, PI = west and PI * 1.5 = south
     */
    viewDirectionAngle: number | null;
    /**
     * The ground coordinates of the image corners (in image world projection).
     */
    groundCoordinates: import("ol/coordinate").Coordinate[];
    /**
     * The center point of the image in world coordinates (in image world projection).
     */
    centerPointOnGround: import("ol/coordinate").Coordinate;
    /**
     * The transformation matrix image to real world (in image world projection).
     */
    pToRealworld: import("@vcmap/cesium").Matrix3;
    /**
     * The transformation matrix real to image (in image world projection).
     */
    pToImage: import("@vcmap/cesium").Matrix4;
    /**
     * The projection center in image world projection
     */
    projectionCenter: import("@vcmap/cesium").Cartesian3;
    /**
     * returns the averageHeight of the image or 0 if not defined. Be sure to call calculateAverageHeight before hand.
     */
    readonly averageHeight: number;
    /**
     * returns whether this image supports exact Coordinate transformation
     */
    readonly hasCamera: boolean;
    transformImage2RealWorld(imageCoordinate: import("ol/coordinate").Coordinate, optAvgHeight?: number): import("ol/coordinate").Coordinate;
    transformRealWorld2Image(worldCoordinate: import("ol/coordinate").Coordinate, optAvgHeight?: number): import("ol/coordinate").Coordinate;
    /**
     * calculates the averageHeight of this image, if a terrainProvider is given the height will be requested
     */
    calculateImageAverageHeight(): Promise<void>;
}

export interface ObliqueImageMetaOptions {
    "principal-point"?: import("ol/coordinate").Coordinate | undefined;
    "pixel-size"?: import("ol/coordinate").Coordinate | undefined;
    "radial-distorsion-expected-2-found"?: number[] | undefined;
    "radial-distorsion-found-2-expected"?: number[] | undefined;
    size: import("ol/size").Size;
    tileSize: import("ol/size").Size;
    tileResolution: number[];
    projection: Projection;
    url: string;
    terrainProvider?: import("@vcmap/cesium").CesiumTerrainProvider;
    name: string;
    format?: string | undefined;
}

export class ObliqueImageMeta {
    constructor(options: ObliqueImageMetaOptions);
    /**
     * The name of the camera associated with these meta data
     */
    readonly name: string;
    principalPoint: import("ol/coordinate").Coordinate | undefined;
    pixelSize: import("ol/coordinate").Coordinate | undefined;
    radialE2F: number[] | undefined;
    radialF2E: number[] | undefined;
    hasRadial: boolean;
    /**
     * The size of the images associated with this meta data
     */
    size: import("ol/size").Size;
    /**
     * The tile size of the images associated with this meta data
     */
    tileSize: import("ol/size").Size;
    /**
     * The tile resolutions of the images associated with this meta data
     */
    tileResolution: number[];
    /**
     * The world projection of the images associated with this meta
     */
    projection: Projection;
    url: string;
    /**
     * An optional terrain provider
     */
    terrainProvider: import("@vcmap/cesium").CesiumTerrainProvider | undefined;
    format: string;
    /**
     * Removes radial distortion in image coordinates. Radial coefficients must be provided
     * @param [useF2E = false] - useFound2Expected, if not true expectedToFound is used
     */
    radialDistortionCoordinate(coordinate: import("ol/coordinate").Coordinate, useF2E?: boolean): import("ol/coordinate").Coordinate;
}

/**
 */
export interface ObliqueViewPoint {
    /**
     * in mercator
    */
    center: import("ol/coordinate").Coordinate;
    zoom: number;
    direction: ObliqueViewDirection;
}

export class ObliqueProvider {
    constructor(olMap: import("ol").Map);





    /**
     * Event raised once a new image is set on the provider. Will be passed the new image as the only argument.
     */
    imageChanged: VcsEvent<ObliqueImage>;
    /**
     * Whether the post render handler should switch on image edge. Setting
     * this to false will suspend all post render handler switches.
     */
    switchEnabled: boolean;
    /**
     * Threshold from 0 to 1 to define when to start switching to other images. Where 0 indicates
     * to only switch, when the view center is outside of the image and 1 to always switch. 0.2 would start switching
     * if the view center is within the outer 20% of the image.
     */
    switchThreshold: number;
    mapChangeEvent: any;
    loading: any;
    active: any;
    readonly currentImage: ObliqueImage | null;
    readonly collection: ObliqueCollection | null;
    /**
     * Set a new collection. The collection must be loaded.
     * If a previous collection was set, the current image and its resources will be removed from the olMap.
     */
    setCollection(collection: ObliqueCollection): void;
    /**
     * Activate the provider, its current view and its post render handler
     */
    activate(): void;
    /**
     * Deactivates the provider, removing the current view and post render handler from the map
     */
    deactivate(): void;
    /**
     * Sets the current image
     * @param [optCenter] - mercator coordinates of an optional center to use. uses the images center if undefined
     */
    setImage(image: ObliqueImage, optCenter?: import("ol/coordinate").Coordinate): Promise<boolean>;
    /**
     * Sets a new image based on a ground coordinate and a direction.
     */
    setView(coordinate: import("ol/coordinate").Coordinate, direction: ObliqueViewDirection, zoom?: number): Promise<void>;
    /**
     * Returns a viewpoint for the currently set view.
     */
    getView(): Promise<ObliqueViewPoint>;
    /**
     * Destroys all openlayers resources created by this oblique provider
     */
    destroy(): void;
}

export interface ObliqueViewOptions {
    minZoom: number;
    maxZoom: number;
    scaleFactor: number;
    hideLevels: number;
}

export class ObliqueView {
    constructor(imageMeta: ObliqueImageMeta, options: ObliqueViewOptions);
    id: string;
    size: import("ol/size").Size;
    url: string;
    tileSize: import("ol/size").Size;
    format: string;
    minZoom: number;
    maxZoom: number;
    scaleFactor: number;
    tileResolution: number[];
    /**
     * The view for these oblique images.
     */
    view: import("ol/View").default;
    tileImageSource: import("ol/source/TileImage").default;
    /**
     * The layer of these images.
     */
    layer: import("ol/layer/Tile").default<import("ol/source/TileImage").default>;
    /**
     * Sets the layers source to request data for this image
     */
    setImageName(name: string, isDefaultImage?: boolean): void;
}

/**
 * Enumeration of view directions.
 */
export const enum ObliqueViewDirection {
    NORTH,
    EAST,
    SOUTH,
    WEST,
    NADIR
}

export const obliqueViewDirectionNames: {
    [key: string]: ObliqueViewDirection;
};

export function getDirectionName(direction: number): string | undefined;

/**
 * @returns version
 */
export function getVersionFromImageJson(json: any): ObliqueVersion;

export function parseImageMeta(json: ObliqueImageJson, url: string, projection?: Projection, terrainProvider?: import("@vcmap/cesium").CesiumTerrainProvider): ObliqueImageMeta[];

export function parseImageData(json: ObliqueImageJson, imageMetas: ObliqueImageMeta[]): ObliqueImage[];

export function parseLegacyImageData(json: ObliqueImageJson, imageMetas: ObliqueImageMeta[]): ObliqueImage[];

export class OverrideClassRegistry<T extends Object|VcsObject> {
    constructor(coreClassRegistry: ClassRegistry<T>);
    /**
     * Called if a class was replaced. Is passed the className
     */
    replaced: VcsEvent<string>;
    /**
     * Called if a class was removed. Is passed the className
     */
    removed: VcsEvent<string>;
    getClassNames(): string[];
    /**
     * Register a class for a given context by name. If the class already exists, it will be replaced and replaced called with the classeName.
     */
    registerClass(contextId: string, className: string, ctor: (...params: any[]) => any): void;
    /**
     * Unregister a previously registered class. You can only unregister classes added to this registry, not the underlying core registry.
     * If when registering this class you have replaced class, it will be re-instated and replaced called.
     * If there is no previously registered class, it will be removed and removed will be called.
     */
    unregisterClass(contextId: string, className: string): void;
    /**
     * Gets the constructor for a registered class or undefined, if no such class was registerd
     */
    getClass(className: string): ((...params: any[]) => any) | undefined;
    hasClass(className: string): boolean;
    /**
     * Create an object of the given className. The constructor is passed args.
     */
    create(className: string, ...args: any[]): T;
    /**
     * A convenience API to pass in a serialized VcsObject directly. It calls create using options.type as the className.
     * Will throw an error if options.type is not a string or options is not an Object.
     * Passes options and args to the constructor in that order.
     */
    createFromTypeOptions(options: any, ...args: any[]): T;
    /**
     * Removes all classes registered from within a certain context. Will re-instate classes overwritten by the context
     * and call the appropriate events, outlined in unregisterClass.
     */
    removeContext(contextId: string): void;
    /**
     * Destroys the override class registry
     */
    destroy(): void;
}

export interface DeclarativeStyleItemConditions {
    conditions: (string[] | string)[];
}

/**
 */
export interface DeclarativeStyleOptions {
    defines?: any | undefined;
    show?: DeclarativeStyleItemConditions | string | boolean | undefined;
    color?: DeclarativeStyleItemConditions | string | undefined;
    /**
     * custom 2D ol condition
    */
    strokeColor?: DeclarativeStyleItemConditions | string | undefined;
    /**
     * custom 2D ol condition
    */
    strokeWidth?: DeclarativeStyleItemConditions | string | undefined;
    scale?: DeclarativeStyleItemConditions | string | undefined;
    pointOutlineWidth?: DeclarativeStyleItemConditions | string | undefined;
    pointOutlineColor?: DeclarativeStyleItemConditions | string | undefined;
    pointSize?: DeclarativeStyleItemConditions | string | undefined;
    /**
     * this should be an icon url
    */
    image?: DeclarativeStyleItemConditions | string | undefined;
    /**
     * a css font string
    */
    font?: DeclarativeStyleItemConditions | string | undefined;
    labelStyle?: DeclarativeStyleItemConditions | string | undefined;
    labelText?: DeclarativeStyleItemConditions | string | undefined;
    labelColor?: DeclarativeStyleItemConditions | string | undefined;
    labelOutlineWidth?: DeclarativeStyleItemConditions | string | undefined;
    labelOutlineColor?: DeclarativeStyleItemConditions | string | undefined;
    anchorLineEnabled?: DeclarativeStyleItemConditions | string | undefined;
    anchorLineColor?: DeclarativeStyleItemConditions | string | undefined;
    heightOffset?: DeclarativeStyleItemConditions | string | undefined;
    verticalOrigin?: DeclarativeStyleItemConditions | string | undefined;
    horizontalOrigin?: DeclarativeStyleItemConditions | string | undefined;
    labelHorizontalOrigin?: DeclarativeStyleItemConditions | string | undefined;
    labelVerticalOrigin?: DeclarativeStyleItemConditions | string | undefined;
}

export interface DeclarativeStyleItemOptions extends StyleItemOptions {
    declarativeStyle?: DeclarativeStyleOptions | undefined;
}

export interface DeclarativeStyleItemSections extends StyleItemSections {
    defaults?: boolean | undefined;
    declarativeStyle?: boolean | undefined;
}

/**
 * Style Object {@see https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/Styling}
 */
export class DeclarativeStyleItem extends StyleItem {
    constructor(options: DeclarativeStyleItemOptions);
    cesiumStyle: import("@vcmap/cesium").Cesium3DTileStyle;


    readonly styleOptions: DeclarativeStyleOptions;
    show: any;
    color: any;
    strokeColor: any;
    strokeWidth: any;
    image: any;
    labelText: any;
    labelColor: any;
    font: any;
    pointSize: any;
    supportedLayers: string[];
    /**
     * Fired on style updates
     */
    styleChanged: VcsEvent<void>;
    colorBlendMode: import("@vcmap/cesium").Cesium3DTileColorBlendMode;
    protected _style: import("ol/style/Style").default | import("ol/style/Style").StyleFunction;
    /**
     * The 2D representation of this style
     */
    style: import("ol/style/Style").default | import("ol/style/Style").StyleFunction;
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
}

export const defaultDeclarativeStyle: DeclarativeStyleItem;

export function getShapeFromOptions(options: VectorStyleItemImage): import("ol/style/RegularShape").default | import("ol/style/Circle").default;

export const shapeCategory: any;

export function getStyleOrDefaultStyle(styleOptions?: DeclarativeStyleItemOptions | VectorStyleItemOptions | StyleItem, defaultStyle?: StyleItem): StyleItem;

export interface FontObject {
    fontStyle: string;
    fontSize: string;
    fontFamily: string;
    fontWeight: string;
    fontVariant: string;
    lineHeight: string;
}

export const enum PatternType {
    NWSE,
    SWNE,
    DIAGONALCROSS,
    NS,
    WE,
    CROSS
}

/**
 * Converts HEX colors to RGB
 */
export function hexToOlColor(h: string, opacity?: number): import("ol/color").Color;

export function cesiumColorToColor(cesiumColor: import("@vcmap/cesium").Color): import("ol/color").Color;

/**
 * converts an openlayers color to a cesium Color
 */
export function olColorToCesiumColor(olColor: import("ol/color").Color): import("@vcmap/cesium").Color;

/**
 * parses a color to an openlayers color
 */
export function parseColor(color: import("ol/color").Color | import("ol/colorlike").ColorLike | number[], defaultColor?: import("ol/color").Color): import("ol/color").Color;

export function getCesiumColor(color: import("ol/color").Color | import("ol/colorlike").ColorLike, defaultColor: import("ol/color").Color): import("@vcmap/cesium").Color;

export function getStringColor(color: import("ol/color").Color | number[] | import("ol/colorlike").ColorLike): string;

export function createPattern(options: VectorStyleItemFill, optCanvas?: HTMLCanvasElement): CanvasPattern;

export function olColorToHex(color: import("ol/color").Color): string;

export function validateHexColor(colorValue: string): boolean;

export function parseFont(font: string | FontObject): FontObject;

export function combineFont(fontObject: FontObject): string;

/**
 * tints the given canvas to the specified color
 */
export function colorInCanvas(canvasContext: CanvasRenderingContext2D, color: import("ol/color").Color, size: import("ol/size").Size, optOrigin?: import("ol/size").Size): void;

/**
 * @returns // XXX FillOptions?
 */
export function getFillOptions(item: import("ol/style/Text").default | import("ol/style/RegularShape").default): import("ol/style/Fill").Options | undefined;

export function getStrokeOptions(stroke: import("ol/style/Stroke").default): import("ol/style/Stroke").Options;

export function getTextOptions(text: import("ol/style/Text").default): VectorStyleItemText;

export function getTextFromOptions(options: VectorStyleItemText): import("ol/style/Text").default;

export function getCssStyleFromTextStyle(textStyle: import("ol/style/Text").default): any;

export const emptyStyle: import("ol/style/Style").default;

export const emptyColor: import("ol/color").Color;

export const whiteColor: import("ol/color").Color;

export const blackColor: import("ol/color").Color;

export function getDefaultVectorStyleItemOptions(): VectorStyleItemOptions;

/**
 * returns the cesium3DTilesetStyle Condition with the value as the given Attribute
 * The condition checks for undefined and null
 */
export function getDefaultCondition(attribute: string, isColor?: boolean): string[][];

export const defaultExtrudedHeightCondition: string;

/**
 */
export interface StyleItemLegendEntry {
    /**
     * the color to display
    */
    color: string;
    /**
     * the name to display for the given color
    */
    name: string | {
        [key: string]: string;
    };
}

/**
 */
export interface StyleItemOptions extends VcsObjectOptions {
    /**
     * colorBlendMode for 3D Tiledataset @see https://cesiumjs.org/import("@vcmap/cesium").Build/Documentation/Cesium3DTileColorBlendMode.html
    */
    colorBlendMode?: number;
}

export interface StyleItemSections {
    meta?: boolean | undefined;
}

/**
 * An abstract style definition which can be applied to a layer
 */
export class StyleItem extends VcsObject {
    constructor(options: StyleItemOptions);
    supportedLayers: string[];
    /**
     * The 3D representation of this style
     */
    cesiumStyle: import("@vcmap/cesium").Cesium3DTileStyle;
    /**
     * Fired on style updates
     */
    styleChanged: VcsEvent<void>;
    colorBlendMode: import("@vcmap/cesium").Cesium3DTileColorBlendMode;
    protected _style: import("ol/style/Style").default | import("ol/style/Style").StyleFunction;
    style: any;
    isSupported(className: string): boolean;
    /**
     * Clones this style. Does not pass the name property.
     */
    clone(result?: StyleItem): StyleItem;
    assign(styleItem: StyleItem): StyleItem;
    /**
     * Tests if two styleItems are equivalent. Does not match the name property (e.g. identifier)
     */
    equals(styleItem: StyleItem): boolean;
    protected _styleChanged(): void;
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
}

export interface VectorStyleItemPattern {
    type: PatternType;
    color: import("ol/color").Color | import("ol/colorlike").ColorLike;
    width: number;
    size: number;
}

export interface VectorStyleItemFill {
    color: import("ol/color").Color | import("ol/colorlike").ColorLike;
    pattern?: VectorStyleItemPattern | undefined;
}

/**
 * This is either <b>olx.style.IconOptions</b> or <b>olx.style.CircleOptions</b>
 */
export interface VectorStyleItemImage {
    src?: string | undefined;
    scale?: number | import("ol/size").Size | undefined;
    opacity?: number | undefined;
    color?: import("ol/color").Color | import("ol/colorlike").ColorLike | undefined;
    fill?: import("ol/style/Fill").Options | import("ol/style/Fill").default | undefined;
    stroke?: import("ol/style/Stroke").Options | import("ol/style/Stroke").default | undefined;
    radius?: number | undefined;
    points?: number | undefined;
    angle?: number | undefined;
    anchor?: number[] | undefined;
    /**
     * vcs:undocumented legacy
    */
    circle?: VectorStyleItemImage | undefined;
    /**
     * vcs:undocumented legacy
    */
    icon?: VectorStyleItemImage | undefined;
    /**
     * vcs:undocumented styleEditor
    */
    currentImage?: string | undefined;
}

export interface VectorStyleItemText {
    text?: string | undefined;
    font?: string | FontObject | undefined;
    fill?: import("ol/style/Fill").Options | import("ol/style/Fill").default | undefined;
    stroke?: import("ol/style/Stroke").Options | import("ol/style/Stroke").default | undefined;
    textBaseline?: string | undefined;
    offsetX?: number | undefined;
    offsetY?: number | undefined;
}

export interface VectorStyleItemExclusion {
    fill: boolean;
    stroke: boolean;
    image: boolean;
}

export interface VectorStyleItemSections extends StyleItemSections {
    fill?: boolean | undefined;
    stroke?: boolean | undefined;
    text?: boolean | undefined;
    image?: boolean | undefined;
    label?: boolean | undefined;
}

export const enum OlcsGeometryType {
    POLYGON,
    POLYLINE,
    POINT
}

export interface VectorStyleItemOptions extends StyleItemOptions {
    fill?: VectorStyleItemFill | false | undefined;
    stroke?: import("ol/style/Stroke").Options | false | undefined;
    image?: VectorStyleItemImage | false | undefined;
    text?: VectorStyleItemText | undefined;
    label?: string | undefined;
}

/**
 * Is set on a feature and is used to signal that the feature has a specific vectorStyleItem.
 * Is set by the Editor if the layerStyle is overwritten. The VectorLayer layer assures this style is set, if
 * the style on the layer is not a DeclarativeStyle
 */
export const vectorStyleSymbol: symbol;

export class VectorStyleItem extends StyleItem {
    constructor(options: VectorStyleItemOptions);
    exclude: VectorStyleItemExclusion;

    validateOptions(options: VectorStyleItemOptions): void;
    fillColor: any;
    /**
     * the current fill color as a cesium color
     */
    readonly cesiumFillColor: import("@vcmap/cesium").Color;
    pattern: any;
    stroke: any;
    label: any;
    text: any;
    image: any;
    style: any;
    updateCesiumStyleColor(silent: boolean): void;
    getOptionsForFeature(feature: import("ol").Feature<import("ol/geom/Geometry").default>): VectorStyleItemOptions;
    /**
     * Exclude a section from this style. Excluded section are not returned and cannot be assigned via .assign.
     * Setting the section over a property will remove it from the excluded sections.
     * @param section - one of fill, stroke, image
     */
    unset(section: string): void;
    supportedLayers: string[];
    /**
     * The 3D representation of this style
     */
    cesiumStyle: import("@vcmap/cesium").Cesium3DTileStyle;
    /**
     * Fired on style updates
     */
    styleChanged: VcsEvent<void>;
    colorBlendMode: import("@vcmap/cesium").Cesium3DTileColorBlendMode;
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
}

export const defaultVectorStyle: VectorStyleItem;

export function fromCesiumColor(cesiumColor: import("@vcmap/cesium").Color): VectorStyleItem;

export function embedIconsInStyle(obj: VectorStyleItemOptions, embeddedIcons?: string[]): VectorStyleItemOptions;

export function writeStyle(style: StyleItem, vcsMeta?: VcsMeta): VcsMeta;

/**
 * Object to define an entity which is clipped by this ClippingObject
 */
export interface ClippingObjectEntityOption {
    layerName: string;
    entityId: string;
}

/**
 */
export interface ClippingObjectOptions {
    layerNames?: string[] | undefined;
    entities?: ClippingObjectEntityOption[] | undefined;
    clippingPlaneCollection?: import("@vcmap/cesium").ClippingPlaneCollection | undefined;
    terrain?: boolean;
    /**
     * if not local, coordinates are expected in ECEF
    */
    local?: boolean;
}

/**
 * The ClippingObject is a container for a Cesium.ClippingPlaneCollection. The container holds information on the
 * targeted Cesium objects, based on layerNames (for [CesiumTilesetLayer]{@link CesiumTilesetLayer}) or
 * layerName and entity id for Cesium.DataSourceLayer which are part of an [DataSourceLayer]{@link DataSource} layer.
 * Adding a ClippingObject to the [ClippingObjectManager]{@link ClippingObjectManager} applies the
 * objects Cesium.ClippingPlaneCollection where applicable. Once added, changes to the targets of the object are tracked.
 * To update the Cesium.ClippingPlaneCollection or its definitions, you must trigger an update by setting the clippingPlaneCollection
 * property to the new definition.
 */
export class ClippingObject {
    constructor(options?: ClippingObjectOptions);
    id: string;
    /**
     * The current layerNames. Use add/removeLayer to manipulate.
     */
    readonly layerNames: string[];
    /**
     * The current entities and their respective layerNames. Use add/removeEntity to manipulate
     */
    readonly entities: ClippingObjectEntityOption[];
    /**
     * Key is a semantic identifier, eg. layerName or layerName-entitiyId, depending on the target. Targets
     * represent Cesium Object which support the clippingPlanes API
     */
    targets: Map<string | symbol, import("@vcmap/cesium").Entity | import("@vcmap/cesium").Cesium3DTileset | import("@vcmap/cesium").Globe>;
    /**
     * Event, raised on a change of targets
     */
    targetsUpdated: VcsEvent<void>;
    /**
     * Event, raised on changes to the clippingPlaneCollection property
     */
    clippingPlaneUpdated: VcsEvent<void>;
    clippingPlaneCollection: any;
    terrain: any;
    local: any;
    setLayerCollection(layerCollection: LayerCollection): void;
    handleLayerChanged(layer: Layer): void;
    handleMapChanged(map: VcsMap | null): void;
    /**
     * add a layer name to the ClippingObject's layerNames array
     */
    addLayer(layerName: string): void;
    /**
     * removes a layer from the ClippingObject's layerNames array
     */
    removeLayer(layerName: string): void;
    /**
     * add an entity to the ClippingObject's entities array
     */
    addEntity(layerName: string, entityId: string): void;
    /**
     * remove entity from the ClippingObject's entities array
     */
    removeEntity(layerName: string, entityId: string): void;
}

/**
 * ClippingObjectManager, a singleton Class for managing [ClippingObjects]{@link ClippingObject}. The manager takes care to only apply a
 * single [ClippingObject]{@link ClippingObject} to a target, such as a Cesium3DTileset or Entity.
 * The manager ensures, [ClippingObjects]{@link ClippingObject} which
 * can be manipulated by the user take precedence over other [ClippingObjects]{@link ClippingObject}.
 * [ClippingObjects]{@link ClippingObject} with the same target get
 * overwritten in the order they where added to the manager. Exclusive [ClippingObjects]{@link ClippingObject} are always applied last, even
 * if a default [ClippingObject]{@link ClippingObject} is added after.
 */
export class ClippingObjectManager {
    initialized: boolean;
    suspendUpdate: any;
    mapActivated(map: VcsMap): void;
    /**
     * Add a default [ClippingObject]{@link ClippingObject} to the manager. The order in which objects are added, determines their priority.
     * In case two objects have the same target, the one added last is applied. Should the last added object be removed,
     * the first one is re-applied. An object may not be added if is already part of the manager, use [hasClippingObject]{@link ClippingObjectManager#hasClippingObject}
     * to test.
     */
    addClippingObject(clippingObject: ClippingObject): void;
    /**
     * Remove a default [ClippingObject]{@link ClippingObject} instance from the manager.
     */
    removeClippingObject(clippingObject: ClippingObject): void;
    /**
     * Test if a {@link ClippingObject} is part of managers context
     */
    hasClippingObject(clippingObject: ClippingObject): boolean;
    /**
     * Sets an Array of [ClippingObjects]{@link ClippingObject} to be added to the managers context. Exclusive objects
     * are intended for [ClippingObjects]{@link ClippingObject} which can be directly manipulated by the user. They
     * are always applied last and will overwrite any managed default [ClippingObject]{@link ClippingObject} with the same targets.
     * The manager will only allow a single context (eg. one widget/plugin) for exclusive objects. Should the current context be switched or cleared, the provided
     * callback is called to inform the setting context of its removal.
     */
    setExclusiveClippingObjects(clippingObjects: ClippingObject[], removedCb: (...params: any[]) => any): void;
    /**
     * Clears the exclusive set of [ClippingObject]{@link ClippingObject}. If called with the silent flag, the
     * removed callback is not called (eg. when removing exclusive clipping objects from the same context).
     */
    clearExclusiveClippingObjects(silent?: boolean): void;
    /**
     * Destroys this clippingObject Manager
     */
    destroy(): void;
}

/**
 * Options to the define how Cesium.ClippingPlanes are created from a ol.Feature.
 */
export interface CreationOptions {
    /**
     * specify the clip direction. If true, everything outside the clippingPlaneCollection should be cut off
    */
    reverse?: boolean | undefined;
    /**
     * specify whether to create the vertical clipping planes
    */
    createVerticalPlanes?: boolean | undefined;
    /**
     * specify whether to create the horizontal clipping plane on the top level of an extruded geometry
    */
    createTopPlane?: boolean | undefined;
    /**
     * specify whether to create the horizontal clipping plane on the ground level
    */
    createBottomPlane?: boolean | undefined;
    /**
     * create 2 planes at the end of a line with only two coordinates
    */
    createEndingPlanes?: boolean | undefined;
}

/**
 * create a Cesium ClippingPlaneCollection based on a given feature having a multi-curve, polygon, or extruded solid geometry
 * @param feature - base for calculating the clipping planes.
 * @param [transformMatrix] - 4x4 matrix specifying the transform of clipping planes from Earth's fixed frame to another one
 */
export function createClippingPlaneCollection(feature: import("ol").Feature<import("ol/geom/Geometry").default>, options?: CreationOptions, transformMatrix?: import("@vcmap/cesium").Matrix4): import("@vcmap/cesium").ClippingPlaneCollection | null;

/**
 * copies the clippingplanes and the properties from source to result
 * @param [transformMatrix] - 4x4 matrix specifying the transform of clipping planes from Earth's fixed frame to another one
 * @param [originPoint] - the origin point of the transformation target, so the plane distance can be set correctly
 */
export function copyClippingPlanesToCollection(source: import("@vcmap/cesium").ClippingPlaneCollection, result: import("@vcmap/cesium").ClippingPlaneCollection, transformMatrix?: import("@vcmap/cesium").Matrix4, originPoint?: import("@vcmap/cesium").Cartesian3): import("@vcmap/cesium").ClippingPlaneCollection;

export function clearClippingPlanes(target: import("@vcmap/cesium").Globe | import("@vcmap/cesium").Cesium3DTileset | import("@vcmap/cesium").Entity): void;

export function setClippingPlanes(target: import("@vcmap/cesium").Globe | import("@vcmap/cesium").Cesium3DTileset | import("@vcmap/cesium").Entity, clippingPlaneCollection: import("@vcmap/cesium").ClippingPlaneCollection, local?: boolean): void;

/**
 * Creates a new feature at the given coordinate, which can be set on a {@link ClippingObjectEditor}.
 * @param coordinate - in WGS84
 * @param [offsetDistance = 25] - the offset from the coordinate to use for the size of the geometry
 * @returns - the features geometry is in web mercator
 */
export function createClippingFeature(coordinate: import("ol/coordinate").Coordinate, camera: import("@vcmap/cesium").Camera, vertical?: boolean, offsetDistance?: number): import("ol").Feature<import("ol/geom/Geometry").default>;

/**
 * Gets the clipping options for the current feature to be infinite or not for the given feature created by
 * {@link createClippingFeature}.
 * @param [feature] - the feature created by {@link createClippingFeature}
 */
export function getClippingOptions(feature?: import("ol").Feature<import("ol/geom/Geometry").default>, infinite?: boolean): CreationOptions;

/**
 * A generic array based collection. Implements the Symbol.iterator (e.g. [...collection])
 * @param [uniqueKey = 'name'] - a key to maintain uniquely within the collection. passing false disables uniqueness.
 */
export class Collection<T extends any> {
    constructor(uniqueKey?: string | symbol | boolean);
    /**
     * Creates a Collection from an iterable, such as an Array.
     * @param [uniqueKey = 'name'] - a key to maintain uniquely within the collection. passing false disables uniqueness.
     */
    static from<T extends any>(iterable: Iterable<T>, uniqueKey?: string | symbol | boolean): Collection<T>;
    protected _array: T[];
    /**
     * Event raised if an item is added. Is passed the added item.
     */
    added: VcsEvent<T>;
    /**
     * Event raised if an item is removed. Is passed the removed item.
     */
    removed: VcsEvent<T>;
    /**
     * The key by which to check uniqueness against. undefined if no uniqueness constraint is set.
     */
    readonly uniqueKey: string | symbol;
    readonly size: number;
    /**
     * Returns an item identified by the unique constraint key. Returns null, if there is no uniqueness constraint.
     * @param value - the value to test against. does a shallow comparison, if the passed a non-atomic value
     */
    getByKey(value: any): T | undefined;
    protected _checkUniqueness(item: T): boolean;
    /**
     * Adds an item to the collection.
     * @param item - the item to be inserted
     * @returns the index at which the item was inserted
     */
    add(item: T): number | null;
    /**
     * Removes an item from the collection
     */
    remove(item: T): void;
    /**
     * Equivalent to Array.prototype.includes
     */
    has(item: T): boolean;
    /**
     * Returns true, if the key exists. Returns undefined, if there is no uniqueness constraint.
     */
    hasKey(value: any): boolean;
    /**
     * clears the array
     */
    clear(): void;
    /**
     * Destroys the collection, clearing the array and all its events
     */
    destroy(): void;
}

export function getShortLocaleDate(date: Date, locale?: string): string;

export function getShortLocaleTime(date: Date, locale?: string): string;

export function getISODateString(date: Date): string;

export function getDayOfYear(date: Date): number;

export function isLeapYear(date: Date): boolean;

/**
 * Tracks layer exclusivity, added to every {@link LayerCollection}.
 */
export class ExclusiveManager {
    /**
     * The layers managed by this manager. The key is the group.
     */
    layers: Map<string | symbol, Set<Layer>>;
    /**
     * registers a Layer as Exclusive, the activation of a layer triggers the deactivation of all other exclusive Layers.
     * The layer collection adds exclusive layers to the manager on adding the layer to the collection.
     * @param layer - layer to register
     */
    registerLayer(layer: Layer): void;
    /**
     * Removes a layer from tracking. Layer collections remove the layer once they are removed from them.
     * @param layer - layer to unregister
     */
    unregisterLayer(layer: Layer): void;
    handleSplitDirectionChanged(layer: Layer): void;
    /**
     * handles the changing of a layer
     */
    handleLayerActivated(layer: Layer): void;
    handleExclusiveGroupsChanged(layer: Layer): void;
    /**
     * Gets all layers in the given group
     */
    getActiveLayersForGroup(group: string): Layer[];
    /**
     * Clears all layer groups
     */
    clear(): void;
    /**
     * Destroys the ExclusiveManager
     */
    destroy(): void;
}

/**
 */
export interface ExtentOptions {
    type?: string;
    /**
     * if not specified, the extent of the projection is used
    */
    coordinates?: import("ol/extent").Extent | undefined;
    /**
     * if not specified the default projection is assumed
    */
    projection?: ProjectionOptions;
}

/**
 * Extent Class
 * @param [options] - object
 */
export class Extent {
    constructor(options?: ExtentOptions);
    static className: string;
    projection: Projection;
    extent: import("ol/extent").Extent | null;
    getCoordinatesInProjection(destination: Projection, result?: import("ol/extent").Extent): import("ol/extent").Extent;
    /**
     * only checks for null/nan numbers, does not check for spatial validity of the extent
     * @returns true if extent is valid
     */
    isValid(): boolean;
    toJSON(): ExtentOptions;
    clone(): Extent;
    equals(extent: Extent): boolean;
    /**
     * validates extent options, checks for valid projection and the geometry of the given coordinates.
     * The Coordinate extent is also valid if its a point extent
     */
    static validateOptions(options: ExtentOptions): boolean;
    static WGS_84_EXTENT: import("ol/extent").Extent;
}

/**
 * validates if a point is renderable
 */
export function validateCircle(circle: import("ol/geom/Circle").default): boolean;

export function getStylesArray(style: void | import("ol/style/Style").StyleLike, feature: import("ol").Feature<import("ol/geom/Geometry").default>, resolution?: number): import("ol/style/Style").default[];

export function getMaterialAppearance(scene: import("@vcmap/cesium").Scene, fill: import("ol/style/Fill").default, feature: import("ol").Feature<import("ol/geom/Geometry").default>): import("@vcmap/cesium").MaterialAppearance;

export function createClassificationPrimitive(options: any, geometries: import("@vcmap/cesium").Geometry[], color: import("@vcmap/cesium").Color, classificationType: import("@vcmap/cesium").ClassificationType): import("@vcmap/cesium").ClassificationPrimitive;

export function createPrimitive(scene: import("@vcmap/cesium").Scene, vectorProperties: VectorProperties, allowPicking: boolean, feature: import("ol").Feature<import("ol/geom/Geometry").default>, geometries: import("@vcmap/cesium").Geometry[], style: import("ol/style/Style").default, groundPrimitive: boolean): import("@vcmap/cesium").Primitive | import("@vcmap/cesium").GroundPrimitive | import("@vcmap/cesium").ClassificationPrimitive | null;

export function createOutlinePrimitive(scene: import("@vcmap/cesium").Scene, vectorProperties: VectorProperties, allowPicking: boolean, feature: import("ol").Feature<import("ol/geom/Geometry").default>, geometries: import("@vcmap/cesium").Geometry[], style: import("ol/style/Style").default): import("@vcmap/cesium").Primitive;

export function createLinePrimitive(scene: import("@vcmap/cesium").Scene, vectorProperties: VectorProperties, allowPicking: boolean, feature: import("ol").Feature<import("ol/geom/Geometry").default>, geometries: (import("@vcmap/cesium").PolylineGeometry | import("@vcmap/cesium").GroundPolylineGeometry)[], style: import("ol/style/Style").default, groundPrimitive: boolean): import("@vcmap/cesium").Primitive | import("@vcmap/cesium").GroundPolylinePrimitive | null;

/**
 * returns groundlevel or extracts the minimum height from the coordinates, returns 0 if no z coordinates are set
 */
export function getMinHeightOrGroundLevel(groundLevel: number | null | undefined, coordinates?: import("ol/coordinate").Coordinate[]): number;

/**
 * @param extrudedHeight - should be a number > 0
 */
export function getStoreyHeights(extrudedHeight: number, storeyHeights: number[], storeyNumber: number): number[];

export function validateStoreys(storeys: number, storeyHeights: number[]): void;

export function getHeightAboveGround(feature: import("ol").Feature<import("ol/geom/Geometry").default>, heightReference: import("@vcmap/cesium").HeightReference, vectorProperties: VectorProperties): number;

export function getHeightInfo(feature: import("ol").Feature<import("ol/geom/Geometry").default>, vectorProperties: VectorProperties, coordinates: import("ol/coordinate").Coordinate[]): VectorHeightInfo;

export function getStoreyOptions(storeyHeights: number[], initialHeight: number, down?: boolean, result?: { currentHeight: number; extrudedHeight: number; }[]): { currentHeight: number; extrudedHeight: number; }[];

export function addPrimitivesToContext(feature: import("ol").Feature<import("ol/geom/Geometry").default>, style: import("ol/style/Style").default, geometries: import("ol/geom/SimpleGeometry").default[], vectorProperties: VectorProperties, scene: import("@vcmap/cesium").Scene, geometryFactory: VectorGeometryFactoryType, context: VectorContext | ClusterContext): void;

/**
 * validates if a lineString is renderable
 */
export function validateLineString(lineString: import("ol/geom/LineString").default): boolean;

export function getBillboardOptions(feature: import("ol").Feature<import("ol/geom/Geometry").default>, style: import("ol/style/Style").default, heightReference: import("@vcmap/cesium").HeightReference, vectorProperties: VectorProperties): any | null;

/**
 * extracts cesium label options from a feature and style
 * @param style - style.getText().getFill() is set by default to be #333,
 * if no fill is required set Fill empty by using style.getText().setFill()
 */
export function getLabelOptions(feature: import("ol").Feature<import("ol/geom/Geometry").default>, style: import("ol/style/Style").default, heightReference: import("@vcmap/cesium").HeightReference, vectorProperties: VectorProperties): any | null;

export function getModelOptions(feature: import("ol").Feature<import("ol/geom/Geometry").default>, wgs84Positions: import("ol/coordinate").Coordinate[], positions: import("@vcmap/cesium").Cartesian3[], vectorProperties: VectorProperties, scene: import("@vcmap/cesium").Scene): null | import("@vcmap/cesium").Model[];

/**
 * validates if a point is renderable
 */
export function validatePoint(point: import("ol/geom/Point").default): boolean;

/**
 * returns positions (cartesian3) and WGS84 coordinates
 */
export function getCartesian3AndWGS84FromCoordinates(coordinates: import("ol/coordinate").Coordinate[], heightInfo: VectorHeightInfo): any;

/**
 * TODO maybe add validation Functions to OpenlayersMap
 * validates if a polygon is renderable
 */
export function validatePolygon(polygon: import("ol/geom/Polygon").default): boolean;

export function requestUrl(url: string, init?: RequestInit): Promise<Response>;

export function requestJson(url: string, init?: RequestInit): Promise<any>;

export function requestArrayBuffer(url: string, init?: RequestInit): Promise<ArrayBuffer>;

export function getFlatCoordinatesFromSimpleGeometry(geometry: import("ol/geom/SimpleGeometry").default): import("ol/coordinate").Coordinate[];

export function getFlatCoordinatesFromGeometry(geometry: import("ol/geom/Geometry").default, inputCoordinates?: any[]): import("ol/coordinate").Coordinate[];

export function circleFromCenterRadius(center: import("ol/coordinate").Coordinate, radius: number): import("ol/geom/Circle").default;

export function convertGeometryToPolygon(geometry: import("ol/geom/Geometry").default): import("ol/geom/Geometry").default;

export function enforceEndingVertex(linearRing: import("ol/coordinate").Coordinate[]): void;

export function removeEndingVertex(linearRing: import("ol/coordinate").Coordinate[]): void;

export function removeEndingVertexFromGeometry(geometry: import("ol/geom/Geometry").default): void;

/**
 * enforce a ring to be counter-clockwise
 */
export function enforceRightHand(ring: import("ol/coordinate").Coordinate[]): import("ol/coordinate").Coordinate[];

/**
 * A generic array based collection. Implements the Symbol.iterator (e.g. [...collection])
 * @param [uniqueKey = 'name'] - a key to maintain uniquely within the collection. passing false disables uniqueness.
 */
export class IndexedCollection<T extends any> extends Collection<T> {
    constructor(uniqueKey?: string | symbol | boolean);
    /**
     * Event raised if an item is relocated within the collection. Is passed the moved item.
     */
    moved: VcsEvent<T>;
    /**
     * Get the symbol which is attached to an item prior to its removal. If an item is removed, the current index of the item
     * is set on the item with this symbol.
     */
    readonly previousIndexSymbol: symbol;
    /**
     * Returns an item at index.
     */
    get(index: number): T;
    /**
     * Adds an item to the collection. Can optionally be passed an index at which to insert the item.
     * @param item - the item to be inserted
     * @param [index] - an optional index at which to insert the item. clipped to the last entry
     * @returns the index at which the item was inserted
     */
    add(item: T, index?: number): number | null;
    remove(item: T): void;
    protected _move(item: T, itemIndex: number, targetIndex: number): number;
    /**
     * Lowers an item within the array
     * @param [steps = 1] - an integer number to lower by
     * @returns the new index of the item
     */
    lower(item: T, steps?: number): number | null;
    /**
     * Raises an item within the array
     * @param [steps = 1] - an integer number to lower by
     * @returns the new index of the item
     */
    raise(item: T, steps?: number): number | null;
    /**
     * Returns the index of an item or -1 if it is not part of this collection
     */
    indexOf(item: T): number;
    /**
     * Returns the index of a key. Returns undefined, if there is no uniqueness constraint
     */
    indexOfKey(value: any): number;
    destroy(): void;
}

/**
 * A collection of layers. Manages rendering order and layer exclusivity. Emits state changes for convenience. Passed to
 * {@link Map} for layers available to said map. Layers must have unique names.
 */
export class LayerCollection extends IndexedCollection<Layer> {
    /**
     * Event raised, when a layer of this collection changes its state. Passed the layer.
     */
    stateChanged: VcsEvent<Layer>;
    /**
     * The exclusive manager for this collection. Layers within this collection are automatically added and tracked.
     */
    exclusiveManager: ExclusiveManager;
    /**
     * A symbol to describe the local z index of a layer. The local z index must not equal the layers z index, but is
     * always consistent in comparison to the neighbouring layers. If a layer is moved other then by z index, the collection
     * ensures consistency by setting a new local z index if needed.
     */
    readonly zIndexSymbol: symbol;
    /**
     * Adds a layer to the collection. Can optionally be passed an index at which to insert the layer.
     * @returns returns the layer index or null, if the layers name is not unique
     */
    add(layer: Layer, index?: number): number | null;
    /**
     * Removes a layer from the collection.
     */
    remove(layer: Layer): void;
}

export function getLocaleChangedEvent(): VcsEvent<string>;

/**
 * returns the default browserLocale, if not possible 'en'
 */
export function detectBrowserLocale(): string;

export function getCurrentLocale(): string;

export function setCurrentLocale(value: string): void;

export interface MapCollectionInitializationError {
    error: Error;
    map: VcsMap;
}

export class MapCollection extends Collection<VcsMap> {
    /**
     * The map pointer event handler. The EventHandler is shared amongst all maps within the collection.
     */
    eventHandler: EventHandler;
    /**
     * Collection of layers shared amongst the maps within this collection,
     * layers will be rendered if supported on the currently active map.
     */

    /**
     * Called, if a map fails to initialize. The map causing the error will be removed from the collection.
     */
    initializeError: VcsEvent<MapCollectionInitializationError>;
    /**
     * Called, when a map (typically an oblique map) cannot show the current viewpoint. Is passed
     * the map which cannot show the current viewpoint.
     */
    fallbackMapActivated: VcsEvent<VcsMap>;
    /**
     * Called, when a map is activated. Is passed the activated map.
     */
    mapActivated: VcsEvent<VcsMap>;
    /**
     * Manages the clipping object for the maps in this collection.
     */
    clippingObjectManager: ClippingObjectManager;
    /**
     * The currently active map
     */
    readonly activeMap: VcsMap;
    /**
     * The currently set HTML element in which to render the maps
     */
    readonly target: HTMLElement | null;
    /**
     * Set the layer collection for these maps.
     */
    layerCollection: any;
    /**
     * Set split screen for these maps.
     */
    splitScreen: any;
    /**
     * Adds a map to the collection. This will set the collections target, {@link SplitScreen}
     * and the collections {@link LayerCollection} on the map.
     * It will add map event listeners and pass them to the event handler of this collection.
     */
    add(map: VcsMap): number | null;
    /**
     * Removes the map from the collection. Will also set _splitScreen & target to null and an empty _layerCollection on the map,
     * if the map is currently part of the collection.
     */
    remove(map: VcsMap): void;
    /**
     * Set the target for these maps.
     */
    setTarget(target: string | HTMLElement): void;
    /**
     * Sets the active map. This will 1. get the current viewpoint of an acitve map (if one is set) 2.
     * determine that the map to be activated can show this viewpoint or has no fallback map set and 3.
     * activates the map 4. calls gotoViewpoint with the previous maps viewpoint
     */
    setActiveMap(mapName: string): Promise<void>;

    /**
     * Returns all maps of a specified type
     */
    getByType(type: string): VcsMap[];
    destroy(): void;
}

/**
 * returns a new coordinate ([lon, lat] in degrees) from a distance, bearing and starting coordinate
 * @param coord - [lon, lat] in degrees
 * @param d - distance in m to new coordinate
 * @param brng - bearing in degrees ( 0 == north, 90° == east)
 * @returns ;
 */
export function coordinateAtDistance(coord: number[], d: number, brng: number): number[];

/**
 * returns the initial bearing in degrees (0-360) between two coordinates
 * @param coords1 - [lon, lat] in degrees
 * @param coords2 - [lon, lat] in degrees
 * @returns ;
 */
export function initialBearingBetweenCoords(coords1: number[], coords2: number[]): number;

/**
 * returns distance between two coordinates
 */
export function cartesian2DDistance(point0: import("ol/coordinate").Coordinate, point1: import("ol/coordinate").Coordinate): number;

export function cartesian3DDistance(p1: import("ol/coordinate").Coordinate, p2: import("ol/coordinate").Coordinate): number;

/**
 * A symbol added to override collections.
 */
export const isOverrideCollection: symbol;

/**
 * @param getDynamicContextId - function to get the current dynamic context id
 * @param [serializeItem] - optional function to serialize an item, defaults to returning item.toJSON or item: i => (i.toJSON || i)
 * @param [deserializeItem] - optional desirialization function. defaults to returning the passed object: i => i
 * @param [ctor] - optional constructor to validate deserialized items against. if passed, deserializeItem must be an instance of ctor.
 * @param [determineShadowIndex] - return the index where a shadow should be inserted. only has relevance, if the collection is indexed. previous and current index may be null.
 */
export function makeOverrideCollection<T extends any>(collection: Collection<T>, getDynamicContextId: (...params: any[]) => any, serializeItem?: (...params: any[]) => any, deserializeItem?: (...params: any[]) => any, ctor?: any, determineShadowIndex?: ((...params: any[]) => any) | null): OverrideCollection<T>;

/**
 */
export interface ProjectionOptions {
    type?: string;
    /**
     * EPSG of the projection, for example: "EPSG:4326" if not specified, uses the framework projection
    */
    epsg?: string | number;
    /**
     * definition of the projection. See for example: {@link http://spatialreference.org/ref/epsg/4326/proj4/} proj4
    */
    proj4?: string | undefined | null;
    /**
     * aliases to define
    */
    alias?: string[] | undefined | null;
    /**
     * an alternate prefix to use for custom projection
    */
    prefix?: string | undefined;
}



/**
 * Set the default projections epsg and proj4. Does not update
 * projection created prior to this functions call.
 */
export function setDefaultProjectionOptions(options: ProjectionOptions): void;

/**
 * Projection Class, if no valid options are given, the Projection will initialize with the Framework default Projection
 */
export class Projection {
    constructor(options: ProjectionOptions);
    static className: any;
    /**
     * epsg code in the format "EPSG:25832"
     */
    readonly epsg: string;
    /**
     * proj4js string example for epsg:25832: +proj=utm +zone=33 +ellps=GRS80 +units=m +no_defs
     */
    readonly proj4: string | null;
    readonly proj: import("ol/proj/Projection").default;
    equals(projection: Projection): boolean;
    static transform(dest: Projection, source: Projection, coords: import("ol/coordinate").Coordinate): import("ol/coordinate").Coordinate;
    transformTo(dest: Projection, coords: import("ol/coordinate").Coordinate): import("ol/coordinate").Coordinate;
    static transformCoordinates(dest: Projection, source: Projection, coords: import("ol/coordinate").Coordinate[]): import("ol/coordinate").Coordinate[];
    /**
     * returns a function to transform coordinates from source to dest
     */
    static getTransformer(dest: Projection, source: Projection): import("ol/proj").TransformFunction;
    transformFrom(source: Projection, coords: import("ol/coordinate").Coordinate): import("ol/coordinate").Coordinate;
    /**
     * Returns the object literal representation of this object
     */
    toJSON(): ProjectionOptions;
    /**
     * Fast transform from Web-Mercator to WGS84
     * @param [inPlace] - whether to transform in place
     */
    static mercatorToWgs84(coords: import("ol/coordinate").Coordinate, inPlace?: boolean): import("ol/coordinate").Coordinate;
    /**
     * Fast transform from WGS84 to Web-Mercator
     * @param [inPlace] - whether to transform in place
     */
    static wgs84ToMercator(coords: import("ol/coordinate").Coordinate, inPlace?: boolean): import("ol/coordinate").Coordinate;
    /**
     * validates projection options, combination of epsg code and proj4
     */
    static validateOptions(options: ProjectionOptions): boolean;
    /**
     * parses an epsg code returns empty string if no code has been found
     * for example:
     * parseEPSGCode('epsg:4326') ==> '4326'
     * parseEPSGCode('epsg:4326', 'EPSG:') ==> 'EPSG:4326'
     * parseEPSGCode('asdasd', 'EPSG:') ==> ''
     * @param prefix - default EPSG:
     */
    static parseEPSGCode(value: string | number | undefined, prefix?: string | undefined): string;
}

/**
 * Returns the default Projection.
 */
export function getDefaultProjection(): Projection;

/**
 * wgs84 Projection EPSG Code: 4326
 */
export const wgs84Projection: Projection;

/**
 * mercator Projection EPSG Code: 3857
 */
export const mercatorProjection: Projection;

export class SplitScreen {
    constructor(clippingObjectManager: ClippingObjectManager);
    scene: import("@vcmap/cesium").Scene | null;
    olMap: import("ol/Map").default | null;
    initialized: boolean;
    leftScreenClippingObject: ClippingObject;
    rightScreenClippingObject: ClippingObject;
    originalCameraPercentageChanged: number | null;
    position: any;
    mapActivated(map: VcsMap): void;
    /**
     * Gets the clipping object for a split direction
     */
    getClippingObjectForDirection(splitDirection: import("@vcmap/cesium").SplitDirection): ClippingObject | null;
}

/**
 * compares two numeric properties
 */
export function propertyEqualsEpsilon(left: number, right: number, epsilon: number): boolean;

/**
 * compares two angles in 360 degree range
 * @param left - angle in degree
 * @param right - angle in degree
 * @param epsilon - in degree
 */
export function angleEqualsEpsilon(left: number, right: number, epsilon: number): boolean;

/**
 * compares two coordinates componentwise
 */
export function coordinateEqualsEpsilon(left: import("ol/coordinate").Coordinate, right: import("ol/coordinate").Coordinate, epsilon: number): boolean;

/**
 */
export interface ViewPointOptions extends VcsObjectOptions {
    /**
     * ol3 coordinate array with xyz coordinates (z value is mandatory)
    */
    cameraPosition?: import("ol/coordinate").Coordinate | undefined;
    /**
     * ol3 coordinate array with xyz coordinates (z value is optional)
    */
    groundPosition?: import("ol/coordinate").Coordinate | undefined;
    /**
     * distance between the camera position and the target
    */
    distance?: number | undefined;
    /**
     * angle between 0 and 360 degree
    */
    heading?: number;
    /**
     * angle between 0 and 360 degree
    */
    pitch?: number;
    /**
     * angle between 0 and 360 degree
    */
    roll?: number;
    /**
     * if possible the switching to the new viewpoint will be animated
    */
    animate?: boolean;
    /**
     * animation duration override
    */
    duration?: number | undefined;
    /**
     * a Cesium.EasingFunction name to use for the flight
    */
    easingFunctionName?: string | undefined;
}

/**
 * A Viewpoint Object
 */
export class ViewPoint extends VcsObject {
    constructor(options: ViewPointOptions);
    /**
     * position of the camera (optional) (cameraPosition needs  x, y, and height value)
     * either a cameraPosition or a groundPosition have to be provided
     */
    cameraPosition: import("ol/coordinate").Coordinate;
    /**
     * groundPosition, point on the ground the camera looks at (optional)
     * either a cameraPosition or a groundPosition have to be provided
     */
    groundPosition: import("ol/coordinate").Coordinate;
    /**
     * distance between target and camera position, only needed if a groundPosition is given
     * is used to move the cameraPosition backwards to get some distance from the ground
     */
    distance: number;
    /**
     * heading, angle between 0 and 360 degree 0° = North, 90° = east ...
     */
    heading: number;
    /**
     * pitch in degrees ranges -90 to 90
     */
    pitch: number;
    /**
     * roll in degrees, ranges -90 to 90
     */
    roll: number;
    /**
     * animate this viewpoint when setting it on a map
     */
    animate: boolean;
    /**
     * An optional duration in seconds to override durations when animating this viewpoint
     */
    duration: number | null;
    /**
     * The name of the easing function to use
     */
    easingFunctionName: string | null;
    /**
     * The current easing function
     */
    readonly easingFunction: import("@vcmap/cesium").EasingFunction.Callback | null;
    /**
     * clones the viewpoint
     * @returns viewpoint
     */
    clone(): ViewPoint;
    /**
     * creates a String representation of this viewpoint
     */
    toString(): string;
    /**
     * Creates a viewpoint based on an extent
     */
    static createViewPointFromExtent(extent: import("ol/extent").Extent | Extent): ViewPoint;
    /**
     * creates a new ViewPoint Object from url Paramter
     */
    static parseURLparameter(urlParameter: any): ViewPoint;
    /**
     * Checks if this Viewpoint is Valid
     */
    isValid(): boolean;
    /**
     * compares the provided Viewpoint with this viewpoint componentwise
     */
    equals(other: ViewPoint, epsilon?: number): boolean;
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
}

export class VcsApp {
    readonly id: string;
    readonly maps: OverrideMapCollection;
    readonly layers: OverrideLayerCollection;
    readonly obliqueCollections: OverrideCollection<ObliqueCollection>;
    readonly viewPoints: OverrideCollection<ViewPoint>;
    readonly styles: OverrideCollection<StyleItem>;
    readonly categories: CategoryCollection;
    readonly destroyed: VcsEvent<void>;
    readonly contextAdded: any;
    readonly contextRemoved: any;
    readonly dynamicContextId: string;
    readonly mapClassRegistry: OverrideClassRegistry<VcsMap>;
    readonly layerClassRegistry: OverrideClassRegistry<Layer>;
    readonly styleClassRegistry: OverrideClassRegistry<StyleItem>;
    readonly categoryClassRegistry: OverrideClassRegistry<Category<object | VcsObject>>;
    readonly categoryItemClassRegistry: OverrideClassRegistry<any>;
    readonly tileProviderClassRegistry: OverrideClassRegistry<TileProvider>;
    readonly featureProviderClassRegistry: OverrideClassRegistry<AbstractFeatureProvider>;
    getContextById(id: string): Context;
    protected _parseContext(context: Context): Promise<void>;
    protected _setContextState(context: Context): Promise<void>;
    addContext(context: Context): Promise<void>;
    protected _removeContext(contextId: string): Promise<void>;
    removeContext(contextId: string): Promise<void>;
    /**
     * Destroys the app and all its collections, their content and ui managers.
     */
    destroy(): void;
}

export function getVcsAppById(id: string): VcsApp;

export const contextIdSymbol: symbol;

export interface ContextLayerOptions extends LayerOptions {
    style?: string | StyleItemOptions;
    tileProvider?: TileProviderOptions;
    featureProvider?: AbstractFeatureProviderOptions;
}

export function deserializeMap(vcsApp: VcsApp, mapConfig: VcsMapOptions): VcsMap | null;

export function deserializeViewPoint(viewPointObject: ViewPointOptions): null | ViewPoint;

export function deserializeLayer(vcsApp: VcsApp, layerConfig: ContextLayerOptions): Layer | null;

export function serializeLayer(vcsApp: VcsApp, layer: Layer): ContextLayerOptions;

export function getLayerIndex(current: Layer, previous: Layer, currentIndex: number): number | null;

export function destroyCollection(collection: Collection<any>): void;

export class VcsEvent<T extends any> {
    /**
     * The number of listeners
     */
    readonly numberOfListeners: number;
    /**
     * Adds an event listener. An event listener can only be added once.
     * A listener added multiple times will only be called once.
     * @returns - remove callback. call this function to remove the listener
     */
    addEventListener(listener: (...params: any[]) => any): (...params: any[]) => any;
    /**
     * Removes the provided listener
     * @returns - whether a listener was removed
     */
    removeEventListener(listener: (...params: any[]) => any): boolean;
    /**
     * Raise the event, calling all listeners
     */
    raiseEvent(event?: T): void;
    awaitRaisedEvent(event?: T): Promise<void>;
    /**
     * clears all listeners
     */
    destroy(): void;
}

/**
 */
export interface VcsObjectOptions {
    /**
     * the type of object, typically only used in configs
    */
    type?: string | undefined;
    /**
     * name of the object, if not given a uuid is generated, is used for the framework functions getObjectByName
    */
    name?: string | undefined;
    /**
     * key value store for framework independent values per Object
    */
    properties?: any | undefined;
}

/**
 * baseclass for all Objects
 */
export class VcsObject {
    constructor(options: VcsObjectOptions);
    /**
     * unique Name
     */
    readonly name: string;
    properties: any;
    readonly className: string;
    getLogger(): import("@vcsuite/logger").Logger;
    toJSON(): VcsObjectOptions;
    destroy(): void;
}




export interface OverrideCollectionInterface<T extends any> {
    replaced: VcsEvent<T>;
    shadowMap: Map<string, object[]>;
    override: (item: T) => T;
    parseItems: (items: object[], contextId: string) => Promise<void>;
    removeContext: (contextId: string) => Promise<void>;
    serializeContext: (contextId: string) => object[];
}

export class OverrideCollection<T extends any> extends Collection<T> implements OverrideCollectionInterface<T> {
    replaced: VcsEvent<T>;
    shadowMap: Map<string, object[]>;
    override: (item: T) => T;
    parseItems: (items: object[], contextId: string) => Promise<void>;
    removeContext: (contextId: string) => Promise<void>;
    serializeContext: (contextId: string) => object[];
}

export class OverrideLayerCollection extends LayerCollection implements OverrideCollectionInterface<Layer> {
    replaced: VcsEvent<Layer>;
    shadowMap: Map<string, object[]>;
    override: (item: Layer) => Layer;
    parseItems: (items: object[], contextId: string) => Promise<void>;
    removeContext: (contextId: string) => Promise<void>;
    serializeContext: (contextId: string) => object[];
}

export class OverrideMapCollection extends MapCollection implements OverrideCollectionInterface<VcsMap> {
    replaced: VcsEvent<VcsMap>;
    shadowMap: Map<string, object[]>;
    override: (item: VcsMap) => VcsMap;
    parseItems: (items: object[], contextId: string) => Promise<void>;
    removeContext: (contextId: string) => Promise<void>;
    serializeContext: (contextId: string) => object[];
}

